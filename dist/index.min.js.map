{"version":3,"file":"index.min.js","sources":["../node_modules/core-js/internals/global.js","../node_modules/core-js/internals/fails.js","../node_modules/core-js/internals/descriptors.js","../node_modules/core-js/internals/object-property-is-enumerable.js","../node_modules/core-js/internals/create-property-descriptor.js","../node_modules/core-js/internals/classof-raw.js","../node_modules/core-js/internals/indexed-object.js","../node_modules/core-js/internals/require-object-coercible.js","../node_modules/core-js/internals/to-indexed-object.js","../node_modules/core-js/internals/is-object.js","../node_modules/core-js/internals/to-primitive.js","../node_modules/core-js/internals/to-object.js","../node_modules/core-js/internals/has.js","../node_modules/core-js/internals/document-create-element.js","../node_modules/core-js/internals/ie8-dom-define.js","../node_modules/core-js/internals/object-get-own-property-descriptor.js","../node_modules/core-js/internals/an-object.js","../node_modules/core-js/internals/object-define-property.js","../node_modules/core-js/internals/create-non-enumerable-property.js","../node_modules/core-js/internals/set-global.js","../node_modules/core-js/internals/shared-store.js","../node_modules/core-js/internals/inspect-source.js","../node_modules/core-js/internals/internal-state.js","../node_modules/core-js/internals/native-weak-map.js","../node_modules/core-js/internals/shared.js","../node_modules/core-js/internals/uid.js","../node_modules/core-js/internals/shared-key.js","../node_modules/core-js/internals/hidden-keys.js","../node_modules/core-js/internals/engine-v8-version.js","../node_modules/core-js/internals/redefine.js","../node_modules/core-js/internals/path.js","../node_modules/core-js/internals/get-built-in.js","../node_modules/core-js/internals/to-integer.js","../node_modules/core-js/internals/to-length.js","../node_modules/core-js/internals/to-absolute-index.js","../node_modules/core-js/internals/array-includes.js","../node_modules/core-js/internals/object-keys-internal.js","../node_modules/core-js/internals/enum-bug-keys.js","../node_modules/core-js/internals/object-get-own-property-names.js","../node_modules/core-js/internals/object-get-own-property-symbols.js","../node_modules/core-js/internals/own-keys.js","../node_modules/core-js/internals/copy-constructor-properties.js","../node_modules/core-js/internals/is-forced.js","../node_modules/core-js/internals/export.js","../node_modules/core-js/internals/a-function.js","../node_modules/core-js/internals/is-array.js","../node_modules/core-js/internals/engine-user-agent.js","../node_modules/core-js/internals/native-symbol.js","../node_modules/core-js/internals/use-symbol-as-uid.js","../node_modules/core-js/internals/well-known-symbol.js","../node_modules/core-js/internals/array-species-create.js","../node_modules/core-js/internals/array-iteration.js","../node_modules/core-js/internals/function-bind-context.js","../node_modules/core-js/internals/array-method-has-species-support.js","../node_modules/core-js/modules/es.array.map.js","../node_modules/core-js/internals/array-reduce.js","../node_modules/core-js/internals/array-method-is-strict.js","../node_modules/core-js/internals/engine-is-node.js","../node_modules/core-js/modules/es.array.reduce.js","../node_modules/core-js/modules/es.array.filter.js","../src/cluster.ts","../src/algorithms/utils.ts","../src/algorithms/core.ts","../node_modules/core-js/internals/array-for-each.js","../node_modules/core-js/modules/web.dom-collections.for-each.js","../node_modules/core-js/internals/dom-iterables.js","../node_modules/core-js/modules/web.url.to-json.js","../src/algorithms/grid.ts","../src/algorithms/noop.ts","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/skmeans/dist/node/distance.js","../node_modules/skmeans/dist/node/kinit.js","../node_modules/skmeans/dist/node/main.js","../src/algorithms/kmeans.ts","../node_modules/@turf/clusters-kmeans/dist/es/index.js","../node_modules/core-js/internals/object-keys.js","../node_modules/core-js/internals/object-assign.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/core-js/modules/es.object.assign.js","../node_modules/density-clustering/lib/DBSCAN.js","../node_modules/density-clustering/lib/KMEANS.js","../node_modules/density-clustering/lib/PriorityQueue.js","../node_modules/density-clustering/lib/OPTICS.js","../node_modules/density-clustering/lib/index.js","../src/algorithms/dbscan.ts","../node_modules/@turf/clusters-dbscan/dist/es/index.js","../node_modules/kdbush/src/sort.js","../node_modules/kdbush/src/within.js","../node_modules/kdbush/src/index.js","../node_modules/kdbush/src/range.js","../node_modules/supercluster/index.js","../node_modules/fast-deep-equal/es6/index.js","../src/algorithms/supercluster.ts","../node_modules/core-js/modules/es.array.index-of.js","../node_modules/core-js/internals/create-property.js","../node_modules/core-js/modules/es.array.splice.js","../node_modules/core-js/internals/a-possible-prototype.js","../node_modules/core-js/internals/object-create.js","../node_modules/core-js/internals/object-set-prototype-of.js","../node_modules/core-js/internals/inherit-if-required.js","../node_modules/core-js/internals/object-define-properties.js","../node_modules/core-js/internals/html.js","../node_modules/core-js/internals/string-trim.js","../node_modules/core-js/modules/es.number.constructor.js","../src/renderer.ts","../src/markerclusterer.ts","../src/overlay-view-safe.ts"],"sourcesContent":["var check = function (it) {\n  return it && it.Math == Math && it;\n};\n\n// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nmodule.exports =\n  // eslint-disable-next-line es/no-global-this -- safe\n  check(typeof globalThis == 'object' && globalThis) ||\n  check(typeof window == 'object' && window) ||\n  // eslint-disable-next-line no-restricted-globals -- safe\n  check(typeof self == 'object' && self) ||\n  check(typeof global == 'object' && global) ||\n  // eslint-disable-next-line no-new-func -- fallback\n  (function () { return this; })() || Function('return this')();\n","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (error) {\n    return true;\n  }\n};\n","var fails = require('../internals/fails');\n\n// Detect IE8's incomplete defineProperty implementation\nmodule.exports = !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- required for testing\n  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;\n});\n","'use strict';\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// Nashorn ~ JDK8 bug\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\n\n// `Object.prototype.propertyIsEnumerable` method implementation\n// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n  var descriptor = getOwnPropertyDescriptor(this, V);\n  return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","var fails = require('../internals/fails');\nvar classof = require('../internals/classof-raw');\n\nvar split = ''.split;\n\n// fallback for non-array-like ES3 and non-enumerable old V8 strings\nmodule.exports = fails(function () {\n  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346\n  // eslint-disable-next-line no-prototype-builtins -- safe\n  return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n  return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n","// `RequireObjectCoercible` abstract operation\n// https://tc39.es/ecma262/#sec-requireobjectcoercible\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on \" + it);\n  return it;\n};\n","// toObject with fallback for non-array-like ES3 strings\nvar IndexedObject = require('../internals/indexed-object');\nvar requireObjectCoercible = require('../internals/require-object-coercible');\n\nmodule.exports = function (it) {\n  return IndexedObject(requireObjectCoercible(it));\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","var isObject = require('../internals/is-object');\n\n// `ToPrimitive` abstract operation\n// https://tc39.es/ecma262/#sec-toprimitive\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (input, PREFERRED_STRING) {\n  if (!isObject(input)) return input;\n  var fn, val;\n  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;\n  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var requireObjectCoercible = require('../internals/require-object-coercible');\n\n// `ToObject` abstract operation\n// https://tc39.es/ecma262/#sec-toobject\nmodule.exports = function (argument) {\n  return Object(requireObjectCoercible(argument));\n};\n","var toObject = require('../internals/to-object');\n\nvar hasOwnProperty = {}.hasOwnProperty;\n\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n  return hasOwnProperty.call(toObject(it), key);\n};\n","var global = require('../internals/global');\nvar isObject = require('../internals/is-object');\n\nvar document = global.document;\n// typeof document.createElement is 'object' in old IE\nvar EXISTS = isObject(document) && isObject(document.createElement);\n\nmodule.exports = function (it) {\n  return EXISTS ? document.createElement(it) : {};\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar createElement = require('../internals/document-create-element');\n\n// Thank's IE8 for his funny defineProperty\nmodule.exports = !DESCRIPTORS && !fails(function () {\n  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing\n  return Object.defineProperty(createElement('div'), 'a', {\n    get: function () { return 7; }\n  }).a != 7;\n});\n","var DESCRIPTORS = require('../internals/descriptors');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar toPrimitive = require('../internals/to-primitive');\nvar has = require('../internals/has');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\n\n// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n// `Object.getOwnPropertyDescriptor` method\n// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n  O = toIndexedObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return $getOwnPropertyDescriptor(O, P);\n  } catch (error) { /* empty */ }\n  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n","var isObject = require('../internals/is-object');\n\nmodule.exports = function (it) {\n  if (!isObject(it)) {\n    throw TypeError(String(it) + ' is not an object');\n  } return it;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar IE8_DOM_DEFINE = require('../internals/ie8-dom-define');\nvar anObject = require('../internals/an-object');\nvar toPrimitive = require('../internals/to-primitive');\n\n// eslint-disable-next-line es/no-object-defineproperty -- safe\nvar $defineProperty = Object.defineProperty;\n\n// `Object.defineProperty` method\n// https://tc39.es/ecma262/#sec-object.defineproperty\nexports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return $defineProperty(O, P, Attributes);\n  } catch (error) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","var global = require('../internals/global');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nmodule.exports = function (key, value) {\n  try {\n    createNonEnumerableProperty(global, key, value);\n  } catch (error) {\n    global[key] = value;\n  } return value;\n};\n","var global = require('../internals/global');\nvar setGlobal = require('../internals/set-global');\n\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\n\nmodule.exports = store;\n","var store = require('../internals/shared-store');\n\nvar functionToString = Function.toString;\n\n// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper\nif (typeof store.inspectSource != 'function') {\n  store.inspectSource = function (it) {\n    return functionToString.call(it);\n  };\n}\n\nmodule.exports = store.inspectSource;\n","var NATIVE_WEAK_MAP = require('../internals/native-weak-map');\nvar global = require('../internals/global');\nvar isObject = require('../internals/is-object');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar objectHas = require('../internals/has');\nvar shared = require('../internals/shared-store');\nvar sharedKey = require('../internals/shared-key');\nvar hiddenKeys = require('../internals/hidden-keys');\n\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar WeakMap = global.WeakMap;\nvar set, get, has;\n\nvar enforce = function (it) {\n  return has(it) ? get(it) : set(it, {});\n};\n\nvar getterFor = function (TYPE) {\n  return function (it) {\n    var state;\n    if (!isObject(it) || (state = get(it)).type !== TYPE) {\n      throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n    } return state;\n  };\n};\n\nif (NATIVE_WEAK_MAP || shared.state) {\n  var store = shared.state || (shared.state = new WeakMap());\n  var wmget = store.get;\n  var wmhas = store.has;\n  var wmset = store.set;\n  set = function (it, metadata) {\n    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    wmset.call(store, it, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return wmget.call(store, it) || {};\n  };\n  has = function (it) {\n    return wmhas.call(store, it);\n  };\n} else {\n  var STATE = sharedKey('state');\n  hiddenKeys[STATE] = true;\n  set = function (it, metadata) {\n    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);\n    metadata.facade = it;\n    createNonEnumerableProperty(it, STATE, metadata);\n    return metadata;\n  };\n  get = function (it) {\n    return objectHas(it, STATE) ? it[STATE] : {};\n  };\n  has = function (it) {\n    return objectHas(it, STATE);\n  };\n}\n\nmodule.exports = {\n  set: set,\n  get: get,\n  has: has,\n  enforce: enforce,\n  getterFor: getterFor\n};\n","var global = require('../internals/global');\nvar inspectSource = require('../internals/inspect-source');\n\nvar WeakMap = global.WeakMap;\n\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n","var IS_PURE = require('../internals/is-pure');\nvar store = require('../internals/shared-store');\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: '3.14.0',\n  mode: IS_PURE ? 'pure' : 'global',\n  copyright: 'Â© 2021 Denis Pushkarev (zloirock.ru)'\n});\n","var id = 0;\nvar postfix = Math.random();\n\nmodule.exports = function (key) {\n  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n","var shared = require('../internals/shared');\nvar uid = require('../internals/uid');\n\nvar keys = shared('keys');\n\nmodule.exports = function (key) {\n  return keys[key] || (keys[key] = uid(key));\n};\n","module.exports = {};\n","var global = require('../internals/global');\nvar userAgent = require('../internals/engine-user-agent');\n\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\n\nif (v8) {\n  match = v8.split('.');\n  version = match[0] < 4 ? 1 : match[0] + match[1];\n} else if (userAgent) {\n  match = userAgent.match(/Edge\\/(\\d+)/);\n  if (!match || match[1] >= 74) {\n    match = userAgent.match(/Chrome\\/(\\d+)/);\n    if (match) version = match[1];\n  }\n}\n\nmodule.exports = version && +version;\n","var global = require('../internals/global');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar has = require('../internals/has');\nvar setGlobal = require('../internals/set-global');\nvar inspectSource = require('../internals/inspect-source');\nvar InternalStateModule = require('../internals/internal-state');\n\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n\n(module.exports = function (O, key, value, options) {\n  var unsafe = options ? !!options.unsafe : false;\n  var simple = options ? !!options.enumerable : false;\n  var noTargetGet = options ? !!options.noTargetGet : false;\n  var state;\n  if (typeof value == 'function') {\n    if (typeof key == 'string' && !has(value, 'name')) {\n      createNonEnumerableProperty(value, 'name', key);\n    }\n    state = enforceInternalState(value);\n    if (!state.source) {\n      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');\n    }\n  }\n  if (O === global) {\n    if (simple) O[key] = value;\n    else setGlobal(key, value);\n    return;\n  } else if (!unsafe) {\n    delete O[key];\n  } else if (!noTargetGet && O[key]) {\n    simple = true;\n  }\n  if (simple) O[key] = value;\n  else createNonEnumerableProperty(O, key, value);\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, 'toString', function toString() {\n  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n","var global = require('../internals/global');\n\nmodule.exports = global;\n","var path = require('../internals/path');\nvar global = require('../internals/global');\n\nvar aFunction = function (variable) {\n  return typeof variable == 'function' ? variable : undefined;\n};\n\nmodule.exports = function (namespace, method) {\n  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])\n    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n","var ceil = Math.ceil;\nvar floor = Math.floor;\n\n// `ToInteger` abstract operation\n// https://tc39.es/ecma262/#sec-tointeger\nmodule.exports = function (argument) {\n  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n","var toInteger = require('../internals/to-integer');\n\nvar min = Math.min;\n\n// `ToLength` abstract operation\n// https://tc39.es/ecma262/#sec-tolength\nmodule.exports = function (argument) {\n  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991\n};\n","var toInteger = require('../internals/to-integer');\n\nvar max = Math.max;\nvar min = Math.min;\n\n// Helper for a popular repeating case of the spec:\n// Let integer be ? ToInteger(index).\n// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).\nmodule.exports = function (index, length) {\n  var integer = toInteger(index);\n  return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n","var toIndexedObject = require('../internals/to-indexed-object');\nvar toLength = require('../internals/to-length');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\n\n// `Array.prototype.{ indexOf, includes }` methods implementation\nvar createMethod = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIndexedObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare -- NaN check\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare -- NaN check\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) {\n      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.includes` method\n  // https://tc39.es/ecma262/#sec-array.prototype.includes\n  includes: createMethod(true),\n  // `Array.prototype.indexOf` method\n  // https://tc39.es/ecma262/#sec-array.prototype.indexof\n  indexOf: createMethod(false)\n};\n","var has = require('../internals/has');\nvar toIndexedObject = require('../internals/to-indexed-object');\nvar indexOf = require('../internals/array-includes').indexOf;\nvar hiddenKeys = require('../internals/hidden-keys');\n\nmodule.exports = function (object, names) {\n  var O = toIndexedObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~indexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// IE8- don't enum bug keys\nmodule.exports = [\n  'constructor',\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toLocaleString',\n  'toString',\n  'valueOf'\n];\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\n\n// `Object.getOwnPropertyNames` method\n// https://tc39.es/ecma262/#sec-object.getownpropertynames\n// eslint-disable-next-line es/no-object-getownpropertynames -- safe\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return internalObjectKeys(O, hiddenKeys);\n};\n","// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe\nexports.f = Object.getOwnPropertySymbols;\n","var getBuiltIn = require('../internals/get-built-in');\nvar getOwnPropertyNamesModule = require('../internals/object-get-own-property-names');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar anObject = require('../internals/an-object');\n\n// all object keys, includes non-enumerable and symbols\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n  var keys = getOwnPropertyNamesModule.f(anObject(it));\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n","var has = require('../internals/has');\nvar ownKeys = require('../internals/own-keys');\nvar getOwnPropertyDescriptorModule = require('../internals/object-get-own-property-descriptor');\nvar definePropertyModule = require('../internals/object-define-property');\n\nmodule.exports = function (target, source) {\n  var keys = ownKeys(source);\n  var defineProperty = definePropertyModule.f;\n  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n};\n","var fails = require('../internals/fails');\n\nvar replacement = /#|\\.prototype\\./;\n\nvar isForced = function (feature, detection) {\n  var value = data[normalize(feature)];\n  return value == POLYFILL ? true\n    : value == NATIVE ? false\n    : typeof detection == 'function' ? fails(detection)\n    : !!detection;\n};\n\nvar normalize = isForced.normalize = function (string) {\n  return String(string).replace(replacement, '.').toLowerCase();\n};\n\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\n\nmodule.exports = isForced;\n","var global = require('../internals/global');\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\nvar redefine = require('../internals/redefine');\nvar setGlobal = require('../internals/set-global');\nvar copyConstructorProperties = require('../internals/copy-constructor-properties');\nvar isForced = require('../internals/is-forced');\n\n/*\n  options.target      - name of the target object\n  options.global      - target is the global object\n  options.stat        - export as static methods of target\n  options.proto       - export as prototype methods of target\n  options.real        - real prototype method for the `pure` version\n  options.forced      - export even if the native feature is available\n  options.bind        - bind methods to the target, required for the `pure` version\n  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version\n  options.unsafe      - use the simple assignment of property instead of delete + defineProperty\n  options.sham        - add a flag to not completely full polyfills\n  options.enumerable  - export as enumerable property\n  options.noTargetGet - prevent calling a getter on target\n*/\nmodule.exports = function (options, source) {\n  var TARGET = options.target;\n  var GLOBAL = options.global;\n  var STATIC = options.stat;\n  var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n  if (GLOBAL) {\n    target = global;\n  } else if (STATIC) {\n    target = global[TARGET] || setGlobal(TARGET, {});\n  } else {\n    target = (global[TARGET] || {}).prototype;\n  }\n  if (target) for (key in source) {\n    sourceProperty = source[key];\n    if (options.noTargetGet) {\n      descriptor = getOwnPropertyDescriptor(target, key);\n      targetProperty = descriptor && descriptor.value;\n    } else targetProperty = target[key];\n    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n    // contained in target\n    if (!FORCED && targetProperty !== undefined) {\n      if (typeof sourceProperty === typeof targetProperty) continue;\n      copyConstructorProperties(sourceProperty, targetProperty);\n    }\n    // add a flag to not completely full polyfills\n    if (options.sham || (targetProperty && targetProperty.sham)) {\n      createNonEnumerableProperty(sourceProperty, 'sham', true);\n    }\n    // extend global\n    redefine(target, key, sourceProperty, options);\n  }\n};\n","module.exports = function (it) {\n  if (typeof it != 'function') {\n    throw TypeError(String(it) + ' is not a function');\n  } return it;\n};\n","var classof = require('../internals/classof-raw');\n\n// `IsArray` abstract operation\n// https://tc39.es/ecma262/#sec-isarray\n// eslint-disable-next-line es/no-array-isarray -- safe\nmodule.exports = Array.isArray || function isArray(arg) {\n  return classof(arg) == 'Array';\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n","/* eslint-disable es/no-symbol -- required for testing */\nvar V8_VERSION = require('../internals/engine-v8-version');\nvar fails = require('../internals/fails');\n\n// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n  var symbol = Symbol();\n  // Chrome 38 Symbol has incorrect toString conversion\n  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances\n  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||\n    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances\n    !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n","/* eslint-disable es/no-symbol -- required for testing */\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\n\nmodule.exports = NATIVE_SYMBOL\n  && !Symbol.sham\n  && typeof Symbol.iterator == 'symbol';\n","var global = require('../internals/global');\nvar shared = require('../internals/shared');\nvar has = require('../internals/has');\nvar uid = require('../internals/uid');\nvar NATIVE_SYMBOL = require('../internals/native-symbol');\nvar USE_SYMBOL_AS_UID = require('../internals/use-symbol-as-uid');\n\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\n\nmodule.exports = function (name) {\n  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {\n    if (NATIVE_SYMBOL && has(Symbol, name)) {\n      WellKnownSymbolsStore[name] = Symbol[name];\n    } else {\n      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n    }\n  } return WellKnownSymbolsStore[name];\n};\n","var isObject = require('../internals/is-object');\nvar isArray = require('../internals/is-array');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\n\nvar SPECIES = wellKnownSymbol('species');\n\n// `ArraySpeciesCreate` abstract operation\n// https://tc39.es/ecma262/#sec-arrayspeciescreate\nmodule.exports = function (originalArray, length) {\n  var C;\n  if (isArray(originalArray)) {\n    C = originalArray.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    else if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n};\n","var bind = require('../internals/function-bind-context');\nvar IndexedObject = require('../internals/indexed-object');\nvar toObject = require('../internals/to-object');\nvar toLength = require('../internals/to-length');\nvar arraySpeciesCreate = require('../internals/array-species-create');\n\nvar push = [].push;\n\n// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation\nvar createMethod = function (TYPE) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var IS_FILTER_OUT = TYPE == 7;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  return function ($this, callbackfn, that, specificCreate) {\n    var O = toObject($this);\n    var self = IndexedObject(O);\n    var boundFunction = bind(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var create = specificCreate || arraySpeciesCreate;\n    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;\n    var value, result;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      value = self[index];\n      result = boundFunction(value, index, O);\n      if (TYPE) {\n        if (IS_MAP) target[index] = result; // map\n        else if (result) switch (TYPE) {\n          case 3: return true;              // some\n          case 5: return value;             // find\n          case 6: return index;             // findIndex\n          case 2: push.call(target, value); // filter\n        } else switch (TYPE) {\n          case 4: return false;             // every\n          case 7: push.call(target, value); // filterOut\n        }\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.forEach` method\n  // https://tc39.es/ecma262/#sec-array.prototype.foreach\n  forEach: createMethod(0),\n  // `Array.prototype.map` method\n  // https://tc39.es/ecma262/#sec-array.prototype.map\n  map: createMethod(1),\n  // `Array.prototype.filter` method\n  // https://tc39.es/ecma262/#sec-array.prototype.filter\n  filter: createMethod(2),\n  // `Array.prototype.some` method\n  // https://tc39.es/ecma262/#sec-array.prototype.some\n  some: createMethod(3),\n  // `Array.prototype.every` method\n  // https://tc39.es/ecma262/#sec-array.prototype.every\n  every: createMethod(4),\n  // `Array.prototype.find` method\n  // https://tc39.es/ecma262/#sec-array.prototype.find\n  find: createMethod(5),\n  // `Array.prototype.findIndex` method\n  // https://tc39.es/ecma262/#sec-array.prototype.findIndex\n  findIndex: createMethod(6),\n  // `Array.prototype.filterOut` method\n  // https://github.com/tc39/proposal-array-filtering\n  filterOut: createMethod(7)\n};\n","var aFunction = require('../internals/a-function');\n\n// optional / simple context binding\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 0: return function () {\n      return fn.call(that);\n    };\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","var fails = require('../internals/fails');\nvar wellKnownSymbol = require('../internals/well-known-symbol');\nvar V8_VERSION = require('../internals/engine-v8-version');\n\nvar SPECIES = wellKnownSymbol('species');\n\nmodule.exports = function (METHOD_NAME) {\n  // We can't use this feature detection in V8 since it causes\n  // deoptimization and serious performance degradation\n  // https://github.com/zloirock/core-js/issues/677\n  return V8_VERSION >= 51 || !fails(function () {\n    var array = [];\n    var constructor = array.constructor = {};\n    constructor[SPECIES] = function () {\n      return { foo: 1 };\n    };\n    return array[METHOD_NAME](Boolean).foo !== 1;\n  });\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar $map = require('../internals/array-iteration').map;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');\n\n// `Array.prototype.map` method\n// https://tc39.es/ecma262/#sec-array.prototype.map\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  map: function map(callbackfn /* , thisArg */) {\n    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","var aFunction = require('../internals/a-function');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\nvar toLength = require('../internals/to-length');\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aFunction(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = toLength(O.length);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing\n    method.call(null, argument || function () { throw 1; }, 1);\n  });\n};\n","var classof = require('../internals/classof-raw');\nvar global = require('../internals/global');\n\nmodule.exports = classof(global.process) == 'process';\n","'use strict';\nvar $ = require('../internals/export');\nvar $reduce = require('../internals/array-reduce').left;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar CHROME_VERSION = require('../internals/engine-v8-version');\nvar IS_NODE = require('../internals/engine-is-node');\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar $ = require('../internals/export');\nvar $filter = require('../internals/array-iteration').filter;\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');\n\n// `Array.prototype.filter` method\n// https://tc39.es/ecma262/#sec-array.prototype.filter\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ClusterOptions {\n  position?: google.maps.LatLng | google.maps.LatLngLiteral;\n  markers?: google.maps.Marker[];\n}\n\nexport class Cluster {\n  public marker: google.maps.Marker;\n  public readonly markers?: google.maps.Marker[];\n  protected _position: google.maps.LatLng;\n\n  constructor({ markers, position }: ClusterOptions) {\n    this.markers = markers;\n\n    if (position) {\n      if (position instanceof google.maps.LatLng) {\n        this._position = position;\n      } else {\n        this._position = new google.maps.LatLng(position);\n      }\n    }\n  }\n\n  public get bounds(): google.maps.LatLngBounds | undefined {\n    if (this.markers.length === 0 && !this._position) {\n      return undefined;\n    }\n\n    return this.markers.reduce((bounds, marker) => {\n      return bounds.extend(marker.getPosition());\n    }, new google.maps.LatLngBounds(this._position, this._position));\n  }\n\n  public get position(): google.maps.LatLng {\n    return this._position || this.bounds.getCenter();\n  }\n\n  /**\n   * Get the count of **visible** markers.\n   */\n  public get count(): number {\n    return this.markers.filter((m: google.maps.Marker) => m.getVisible())\n      .length;\n  }\n\n  /**\n   * Add a marker to the cluster.\n   */\n  public push(marker: google.maps.Marker): void {\n    this.markers.push(marker);\n  }\n\n  /**\n   * Cleanup references and remove marker from map.\n   */\n  public delete(): void {\n    if (this.marker) {\n      this.marker.setMap(null);\n      delete this.marker;\n    }\n    this.markers.length = 0;\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const filterMarkersToPaddedViewport = (\n  map: google.maps.Map,\n  mapCanvasProjection: google.maps.MapCanvasProjection,\n  markers: google.maps.Marker[],\n  viewportPadding: number\n): google.maps.Marker[] => {\n  const extendedMapBounds = extendBoundsToPaddedViewport(\n    map.getBounds(),\n    mapCanvasProjection,\n    viewportPadding\n  );\n  return markers.filter((marker) =>\n    extendedMapBounds.contains(marker.getPosition())\n  );\n};\n\n/**\n * Extends a bounds by a number of pixels in each direction.\n */\nexport const extendBoundsToPaddedViewport = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection,\n  pixels: number\n): google.maps.LatLngBounds => {\n  const { northEast, southWest } = latLngBoundsToPixelBounds(\n    bounds,\n    projection\n  );\n  const extendedPixelBounds = extendPixelBounds(\n    { northEast, southWest },\n    pixels\n  );\n  return pixelBoundsToLatLngBounds(extendedPixelBounds, projection);\n};\n\n/**\n * @hidden\n */\nexport const distanceBetweenPoints = (\n  p1: google.maps.LatLngLiteral,\n  p2: google.maps.LatLngLiteral\n): number => {\n  const R = 6371; // Radius of the Earth in km\n  const dLat = ((p2.lat - p1.lat) * Math.PI) / 180;\n  const dLon = ((p2.lng - p1.lng) * Math.PI) / 180;\n  const a =\n    Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n    Math.cos((p1.lat * Math.PI) / 180) *\n      Math.cos((p2.lat * Math.PI) / 180) *\n      Math.sin(dLon / 2) *\n      Math.sin(dLon / 2);\n  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  return R * c;\n};\n\ntype PixelBounds = {\n  northEast: google.maps.Point;\n  southWest: google.maps.Point;\n};\n\n/**\n * @hidden\n */\nconst latLngBoundsToPixelBounds = (\n  bounds: google.maps.LatLngBounds,\n  projection: google.maps.MapCanvasProjection\n): PixelBounds => {\n  return {\n    northEast: projection.fromLatLngToDivPixel(bounds.getNorthEast()),\n    southWest: projection.fromLatLngToDivPixel(bounds.getSouthWest()),\n  };\n};\n\n/**\n * @hidden\n */\nexport const extendPixelBounds = (\n  { northEast, southWest }: PixelBounds,\n  pixels: number\n): PixelBounds => {\n  northEast.x += pixels;\n  northEast.y -= pixels;\n\n  southWest.x -= pixels;\n  southWest.y += pixels;\n\n  return { northEast, southWest };\n};\n\n/**\n * @hidden\n */\nexport const pixelBoundsToLatLngBounds = (\n  { northEast, southWest }: PixelBounds,\n  projection: google.maps.MapCanvasProjection\n): google.maps.LatLngBounds => {\n  const bounds = new google.maps.LatLngBounds();\n  bounds.extend(projection.fromDivPixelToLatLng(northEast));\n  bounds.extend(projection.fromDivPixelToLatLng(southWest));\n  return bounds;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"../cluster\";\nimport { filterMarkersToPaddedViewport } from \"./utils\";\n\nexport interface AlgorithmInput {\n  /**\n   * The map containing the makres and clusters.\n   */\n  map: google.maps.Map;\n  /**\n   * An array of markers to be clustered.\n   *\n   * There are some specific edge cases to be aware of including the following:\n   * * Markers that are not visible.\n   */\n  markers: google.maps.Marker[];\n  /**\n   * The `mapCanvasProjection` enables easy conversion from lat/lng to pixel.\n   *\n   * @see [MapCanvasProjection](https://developers.google.com/maps/documentation/javascript/reference/overlay-view#MapCanvasProjection)\n   */\n  mapCanvasProjection: google.maps.MapCanvasProjection;\n}\n\nexport interface Algorithm {\n  /**\n   * Calculates an array of {@link Cluster}.\n   */\n  calculate: ({ markers, map }: AlgorithmInput) => Cluster[];\n}\n\nexport interface AlgorithmOptions {\n  maxZoom?: number;\n}\n/**\n * @hidden\n */\nexport abstract class AbstractAlgorithm implements Algorithm {\n  protected maxZoom: number;\n\n  constructor({ maxZoom = 16 }: AlgorithmOptions) {\n    this.maxZoom = maxZoom;\n  }\n  /**\n   * Helper function to bypass clustering based upon some map state such as\n   * zoom, number of markers, etc.\n   *\n   * ```typescript\n   *  cluster({markers, map}: AlgorithmInput): Cluster[] {\n   *    if (shouldBypassClustering(map)) {\n   *      return this.noop({markers, map})\n   *    }\n   * }\n   * ```\n   */\n  protected noop({ markers }: AlgorithmInput): Cluster[] {\n    return noop(markers);\n  }\n  /**\n   * Calculates an array of {@link Cluster}. Calculate is separate from\n   * {@link cluster} as it does prepocessing on the markers such as filtering\n   * based upon the viewport as in {@link AbstractViewportAlgorithm}. Caching\n   * and other optimizations can also be done here.\n   */\n  public abstract calculate({ markers, map }: AlgorithmInput): Cluster[];\n\n  /**\n   * Clusters the markers and called from {@link calculate}.\n   */\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport interface ViewportAlgorithmOptions extends AlgorithmOptions {\n  /**\n   * The number of pixels to extend beyond the viewport bounds when filtering\n   * markers prior to clustering.\n   */\n  viewportPadding?: number;\n}\n\n/**\n * Abstract viewport algorithm proves a class to filter markers by a padded\n * viewport. This is a common optimization.\n *\n * @hidden\n */\nexport abstract class AbstractViewportAlgorithm extends AbstractAlgorithm {\n  protected viewportPadding = 60;\n\n  constructor({ viewportPadding = 60, ...options }: ViewportAlgorithmOptions) {\n    super(options);\n    this.viewportPadding = viewportPadding;\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    if (map.getZoom() >= this.maxZoom) {\n      return this.noop({\n        markers,\n        map,\n        mapCanvasProjection,\n      });\n    }\n\n    return this.cluster({\n      markers: filterMarkersToPaddedViewport(\n        map,\n        mapCanvasProjection,\n        markers,\n        this.viewportPadding\n      ),\n      map,\n      mapCanvasProjection,\n    });\n  }\n  protected abstract cluster({ markers, map }: AlgorithmInput): Cluster[];\n}\n\n/**\n * @hidden\n */\nexport const noop = (markers: google.maps.Marker[]): Cluster[] => {\n  const clusters = markers.map(\n    (marker) =>\n      new Cluster({\n        position: marker.getPosition(),\n        markers: [marker],\n      })\n  );\n  return clusters;\n};\n","'use strict';\nvar $forEach = require('../internals/array-iteration').forEach;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\n\nvar STRICT_METHOD = arrayMethodIsStrict('forEach');\n\n// `Array.prototype.forEach` method implementation\n// https://tc39.es/ecma262/#sec-array.prototype.foreach\nmodule.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {\n  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n// eslint-disable-next-line es/no-array-prototype-foreach -- safe\n} : [].forEach;\n","var global = require('../internals/global');\nvar DOMIterables = require('../internals/dom-iterables');\nvar forEach = require('../internals/array-for-each');\nvar createNonEnumerableProperty = require('../internals/create-non-enumerable-property');\n\nfor (var COLLECTION_NAME in DOMIterables) {\n  var Collection = global[COLLECTION_NAME];\n  var CollectionPrototype = Collection && Collection.prototype;\n  // some Chrome versions have non-configurable methods on DOMTokenList\n  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {\n    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);\n  } catch (error) {\n    CollectionPrototype.forEach = forEach;\n  }\n}\n","// iterable DOM collections\n// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods\nmodule.exports = {\n  CSSRuleList: 0,\n  CSSStyleDeclaration: 0,\n  CSSValueList: 0,\n  ClientRectList: 0,\n  DOMRectList: 0,\n  DOMStringList: 0,\n  DOMTokenList: 1,\n  DataTransferItemList: 0,\n  FileList: 0,\n  HTMLAllCollection: 0,\n  HTMLCollection: 0,\n  HTMLFormElement: 0,\n  HTMLSelectElement: 0,\n  MediaList: 0,\n  MimeTypeArray: 0,\n  NamedNodeMap: 0,\n  NodeList: 1,\n  PaintRequestList: 0,\n  Plugin: 0,\n  PluginArray: 0,\n  SVGLengthList: 0,\n  SVGNumberList: 0,\n  SVGPathSegList: 0,\n  SVGPointList: 0,\n  SVGStringList: 0,\n  SVGTransformList: 0,\n  SourceBufferList: 0,\n  StyleSheetList: 0,\n  TextTrackCueList: 0,\n  TextTrackList: 0,\n  TouchList: 0\n};\n","'use strict';\nvar $ = require('../internals/export');\n\n// `URL.prototype.toJSON` method\n// https://url.spec.whatwg.org/#dom-url-tojson\n$({ target: 'URL', proto: true, enumerable: true }, {\n  toJSON: function toJSON() {\n    return URL.prototype.toString.call(this);\n  }\n});\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { distanceBetweenPoints, extendBoundsToPaddedViewport } from \"./utils\";\n\nimport { Cluster } from \"../cluster\";\n\nexport interface GridOptions extends ViewportAlgorithmOptions {\n  gridSize?: number;\n  /**\n   * Max distance between cluster center and point in meters.\n   * @default 10000\n   */\n  maxDistance?: number;\n}\n\n/**\n * The default Grid algorithm historically used in Google Maps marker clustering.\n */\nexport class GridAlgorithm extends AbstractViewportAlgorithm {\n  protected gridSize: number;\n  protected maxDistance: number;\n  protected clusters: Cluster[] = [];\n\n  constructor({ maxDistance = 40000, gridSize = 40, ...options }: GridOptions) {\n    super(options);\n\n    this.maxDistance = maxDistance;\n    this.gridSize = gridSize;\n  }\n\n  protected cluster({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    this.clusters = [];\n    markers.forEach((marker) => {\n      this.addToClosestCluster(marker, map, mapCanvasProjection);\n    });\n\n    return this.clusters;\n  }\n\n  protected addToClosestCluster(\n    marker: google.maps.Marker,\n    map: google.maps.Map,\n    projection: google.maps.MapCanvasProjection\n  ): void {\n    let maxDistance = this.maxDistance; // Some large number\n    let cluster: Cluster = null;\n\n    for (let i = 0; i < this.clusters.length; i++) {\n      const candidate = this.clusters[i];\n      const distance = distanceBetweenPoints(\n        candidate.bounds.getCenter().toJSON(),\n        marker.getPosition().toJSON()\n      );\n\n      if (distance < maxDistance) {\n        maxDistance = distance;\n        cluster = candidate;\n      }\n    }\n\n    if (\n      cluster &&\n      extendBoundsToPaddedViewport(\n        cluster.bounds,\n        projection,\n        this.gridSize\n      ).contains(marker.getPosition())\n    ) {\n      cluster.push(marker);\n    } else {\n      const cluster = new Cluster({ markers: [marker] });\n      this.clusters.push(cluster);\n    }\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput, AlgorithmOptions } from \"./core\";\n\nimport { Cluster } from \"../cluster\";\n\n/**\n * Noop algorithm does not generate any clusters or filter markers by the an extended viewport.\n */\nexport class NoopAlgorithm extends AbstractAlgorithm {\n  constructor({ ...options }: AlgorithmOptions) {\n    super(options);\n  }\n  public calculate({\n    markers,\n    map,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    return this.cluster({ markers, map, mapCanvasProjection });\n  }\n\n  protected cluster(input: AlgorithmInput): Cluster[] {\n    return this.noop(input);\n  }\n}\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","\"use strict\";\n\nmodule.exports = {\n\t/**\n  * Euclidean distance\n  */\n\teudist: function eudist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar d = (v1[i] || 0) - (v2[i] || 0);\n\t\t\tsum += d * d;\n\t\t}\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\tmandist: function mandist(v1, v2, sqrt) {\n\t\tvar len = v1.length;\n\t\tvar sum = 0;\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tsum += Math.abs((v1[i] || 0) - (v2[i] || 0));\n\t\t}\n\n\t\t// Square root not really needed\n\t\treturn sqrt ? Math.sqrt(sum) : sum;\n\t},\n\n\n\t/**\n  * Unidimensional distance\n  */\n\tdist: function dist(v1, v2, sqrt) {\n\t\tvar d = Math.abs(v1 - v2);\n\t\treturn sqrt ? d : d * d;\n\t}\n};\n//# sourceMappingURL=distance.js.map\n","\"use strict\";\n\nvar Distance = require(\"./distance.js\"),\n    eudist = Distance.eudist,\n    dist = Distance.dist;\n\nmodule.exports = {\n\tkmrand: function kmrand(data, k) {\n\t\tvar map = {},\n\t\t    ks = [],\n\t\t    t = k << 2;\n\t\tvar len = data.length;\n\t\tvar multi = data[0].length > 0;\n\n\t\twhile (ks.length < k && t-- > 0) {\n\t\t\tvar d = data[Math.floor(Math.random() * len)];\n\t\t\tvar key = multi ? d.join(\"_\") : \"\" + d;\n\t\t\tif (!map[key]) {\n\t\t\t\tmap[key] = true;\n\t\t\t\tks.push(d);\n\t\t\t}\n\t\t}\n\n\t\tif (ks.length < k) throw new Error(\"Error initializating clusters\");else return ks;\n\t},\n\n\n\t/**\n  * K-means++ initial centroid selection\n  */\n\tkmpp: function kmpp(data, k) {\n\t\tvar distance = data[0].length ? eudist : dist;\n\t\tvar ks = [],\n\t\t    len = data.length;\n\t\tvar multi = data[0].length > 0;\n\t\tvar map = {};\n\n\t\t// First random centroid\n\t\tvar c = data[Math.floor(Math.random() * len)];\n\t\tvar key = multi ? c.join(\"_\") : \"\" + c;\n\t\tks.push(c);\n\t\tmap[key] = true;\n\n\t\t// Retrieve next centroids\n\t\twhile (ks.length < k) {\n\t\t\t// Min Distances between current centroids and data points\n\t\t\tvar dists = [],\n\t\t\t    lk = ks.length;\n\t\t\tvar dsum = 0,\n\t\t\t    prs = [];\n\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar min = Infinity;\n\t\t\t\tfor (var j = 0; j < lk; j++) {\n\t\t\t\t\tvar _dist = distance(data[i], ks[j]);\n\t\t\t\t\tif (_dist <= min) min = _dist;\n\t\t\t\t}\n\t\t\t\tdists[i] = min;\n\t\t\t}\n\n\t\t\t// Sum all min distances\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tdsum += dists[_i];\n\t\t\t}\n\n\t\t\t// Probabilities and cummulative prob (cumsum)\n\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\tprs[_i2] = { i: _i2, v: data[_i2], pr: dists[_i2] / dsum, cs: 0 };\n\t\t\t}\n\n\t\t\t// Sort Probabilities\n\t\t\tprs.sort(function (a, b) {\n\t\t\t\treturn a.pr - b.pr;\n\t\t\t});\n\n\t\t\t// Cummulative Probabilities\n\t\t\tprs[0].cs = prs[0].pr;\n\t\t\tfor (var _i3 = 1; _i3 < len; _i3++) {\n\t\t\t\tprs[_i3].cs = prs[_i3 - 1].cs + prs[_i3].pr;\n\t\t\t}\n\n\t\t\t// Randomize\n\t\t\tvar rnd = Math.random();\n\n\t\t\t// Gets only the items whose cumsum >= rnd\n\t\t\tvar idx = 0;\n\t\t\twhile (idx < len - 1 && prs[idx++].cs < rnd) {}\n\t\t\tks.push(prs[idx - 1].v);\n\t\t\t/*\n   let done = false;\n   while(!done) {\n   \t// this is our new centroid\n   \tc = prs[idx-1].v\n   \tkey = multi? c.join(\"_\") : `${c}`;\n   \tif(!map[key]) {\n   \t\tmap[key] = true;\n   \t\tks.push(c);\n   \t\tdone = true;\n   \t}\n   \telse {\n   \t\tidx++;\n   \t}\n   }\n   */\n\t\t}\n\n\t\treturn ks;\n\t}\n};\n//# sourceMappingURL=kinit.js.map\n","\"use strict\";\n\n/*jshint esversion: 6 */\n\nvar Distance = require(\"./distance.js\"),\n    ClusterInit = require(\"./kinit.js\"),\n    eudist = Distance.eudist,\n    mandist = Distance.mandist,\n    dist = Distance.dist,\n    kmrand = ClusterInit.kmrand,\n    kmpp = ClusterInit.kmpp;\n\nvar MAX = 10000;\n\n/**\n * Inits an array with values\n */\nfunction init(len, val, v) {\n\tv = v || [];\n\tfor (var i = 0; i < len; i++) {\n\t\tv[i] = val;\n\t}return v;\n}\n\nfunction skmeans(data, k, initial, maxit) {\n\tvar ks = [],\n\t    old = [],\n\t    idxs = [],\n\t    dist = [];\n\tvar conv = false,\n\t    it = maxit || MAX;\n\tvar len = data.length,\n\t    vlen = data[0].length,\n\t    multi = vlen > 0;\n\tvar count = [];\n\n\tif (!initial) {\n\t\tvar _idxs = {};\n\t\twhile (ks.length < k) {\n\t\t\tvar idx = Math.floor(Math.random() * len);\n\t\t\tif (!_idxs[idx]) {\n\t\t\t\t_idxs[idx] = true;\n\t\t\t\tks.push(data[idx]);\n\t\t\t}\n\t\t}\n\t} else if (initial == \"kmrand\") {\n\t\tks = kmrand(data, k);\n\t} else if (initial == \"kmpp\") {\n\t\tks = kmpp(data, k);\n\t} else {\n\t\tks = initial;\n\t}\n\n\tdo {\n\t\t// Reset k count\n\t\tinit(k, 0, count);\n\n\t\t// For each value in data, find the nearest centroid\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tvar min = Infinity,\n\t\t\t    _idx = 0;\n\t\t\tfor (var j = 0; j < k; j++) {\n\t\t\t\t// Multidimensional or unidimensional\n\t\t\t\tvar dist = multi ? eudist(data[i], ks[j]) : Math.abs(data[i] - ks[j]);\n\t\t\t\tif (dist <= min) {\n\t\t\t\t\tmin = dist;\n\t\t\t\t\t_idx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidxs[i] = _idx; // Index of the selected centroid for that value\n\t\t\tcount[_idx]++; // Number of values for this centroid\n\t\t}\n\n\t\t// Recalculate centroids\n\t\tvar sum = [],\n\t\t    old = [],\n\t\t    dif = 0;\n\t\tfor (var _j = 0; _j < k; _j++) {\n\t\t\t// Multidimensional or unidimensional\n\t\t\tsum[_j] = multi ? init(vlen, 0, sum[_j]) : 0;\n\t\t\told[_j] = ks[_j];\n\t\t}\n\n\t\t// If multidimensional\n\t\tif (multi) {\n\t\t\tfor (var _j2 = 0; _j2 < k; _j2++) {\n\t\t\t\tks[_j2] = [];\n\t\t\t} // Sum values and count for each centroid\n\t\t\tfor (var _i = 0; _i < len; _i++) {\n\t\t\t\tvar _idx2 = idxs[_i],\n\t\t\t\t    // Centroid for that item\n\t\t\t\tvsum = sum[_idx2],\n\t\t\t\t    // Sum values for this centroid\n\t\t\t\tvect = data[_i]; // Current vector\n\n\t\t\t\t// Accumulate value on the centroid for current vector\n\t\t\t\tfor (var h = 0; h < vlen; h++) {\n\t\t\t\t\tvsum[h] += vect[h];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Calculate the average for each centroid\n\t\t\tconv = true;\n\t\t\tfor (var _j3 = 0; _j3 < k; _j3++) {\n\t\t\t\tvar ksj = ks[_j3],\n\t\t\t\t    // Current centroid\n\t\t\t\tsumj = sum[_j3],\n\t\t\t\t    // Accumulated centroid values\n\t\t\t\toldj = old[_j3],\n\t\t\t\t    // Old centroid value\n\t\t\t\tcj = count[_j3]; // Number of elements for this centroid\n\n\t\t\t\t// New average\n\t\t\t\tfor (var _h = 0; _h < vlen; _h++) {\n\t\t\t\t\tksj[_h] = sumj[_h] / cj || 0; // New centroid\n\t\t\t\t}\n\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tif (conv) {\n\t\t\t\t\tfor (var _h2 = 0; _h2 < vlen; _h2++) {\n\t\t\t\t\t\tif (oldj[_h2] != ksj[_h2]) {\n\t\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If unidimensional\n\t\telse {\n\t\t\t\t// Sum values and count for each centroid\n\t\t\t\tfor (var _i2 = 0; _i2 < len; _i2++) {\n\t\t\t\t\tvar _idx3 = idxs[_i2];\n\t\t\t\t\tsum[_idx3] += data[_i2];\n\t\t\t\t}\n\t\t\t\t// Calculate the average for each centroid\n\t\t\t\tfor (var _j4 = 0; _j4 < k; _j4++) {\n\t\t\t\t\tks[_j4] = sum[_j4] / count[_j4] || 0; // New centroid\n\t\t\t\t}\n\t\t\t\t// Find if centroids have moved\n\t\t\t\tconv = true;\n\t\t\t\tfor (var _j5 = 0; _j5 < k; _j5++) {\n\t\t\t\t\tif (old[_j5] != ks[_j5]) {\n\t\t\t\t\t\tconv = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tconv = conv || --it <= 0;\n\t} while (!conv);\n\n\treturn {\n\t\tit: MAX - it,\n\t\tk: k,\n\t\tidxs: idxs,\n\t\tcentroids: ks\n\t};\n}\n\nmodule.exports = skmeans;\n//# sourceMappingURL=main.js.map\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersKmeans from \"@turf/clusters-kmeans\";\n\nexport interface KmeansAlgorithmOptions extends ViewportAlgorithmOptions {\n  numberOfClusters: number | ((count: number, zoom: number) => number);\n}\n\n/**\n * Experimental algorithm using Kmeans.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-kmeans\n */\nexport class KmeansAlgorithm extends AbstractViewportAlgorithm {\n  protected numberOfClusters:\n    | number\n    | ((count: number, zoom: number) => number);\n\n  constructor({ numberOfClusters, ...options }: KmeansAlgorithmOptions) {\n    super(options);\n    this.numberOfClusters = numberOfClusters;\n  }\n\n  protected cluster({ markers, map }: AlgorithmInput): Cluster[] {\n    const clusters: Cluster[] = [];\n\n    if (markers.length === 0) {\n      return clusters;\n    }\n    const points = featureCollection(\n      markers.map((marker) => {\n        return point([marker.getPosition().lng(), marker.getPosition().lat()]);\n      })\n    );\n\n    let numberOfClusters: number;\n\n    if (this.numberOfClusters instanceof Function) {\n      numberOfClusters = this.numberOfClusters(markers.length, map.getZoom());\n    } else {\n      numberOfClusters = this.numberOfClusters;\n    }\n    clustersKmeans(points, { numberOfClusters }).features.forEach(\n      (point, i) => {\n        if (!clusters[point.properties.cluster]) {\n          clusters[point.properties.cluster] = new Cluster({\n            position: {\n              lng: point.properties.centroid[0],\n              lat: point.properties.centroid[1],\n            },\n            markers: [],\n          });\n        }\n\n        clusters[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return clusters;\n  }\n}\n","import clone from \"@turf/clone\";\nimport { coordAll, featureEach } from \"@turf/meta\";\nimport skmeans from \"skmeans\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters using the k-mean .\n * It uses the [k-means algorithm](https://en.wikipedia.org/wiki/K-means_clustering)\n *\n * @name clustersKmeans\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.numberOfClusters=Math.sqrt(numberOfPoints/2)] numberOfClusters that will be generated\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {[number, number]} centroid - Centroid of the cluster [Longitude, Latitude]\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var options = {numberOfClusters: 7};\n * var clustered = turf.clustersKmeans(points, options);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersKmeans(points, options) {\n    if (options === void 0) { options = {}; }\n    // Default Params\n    var count = points.features.length;\n    options.numberOfClusters =\n        options.numberOfClusters || Math.round(Math.sqrt(count / 2));\n    // numberOfClusters can't be greater than the number of points\n    // fallbacks to count\n    if (options.numberOfClusters > count)\n        options.numberOfClusters = count;\n    // Clone points to prevent any mutations (enabled by default)\n    if (options.mutate !== true)\n        points = clone(points);\n    // collect points coordinates\n    var data = coordAll(points);\n    // create seed to avoid skmeans to drift\n    var initialCentroids = data.slice(0, options.numberOfClusters);\n    // create skmeans clusters\n    var skmeansResult = skmeans(data, options.numberOfClusters, initialCentroids);\n    // store centroids {clusterId: [number, number]}\n    var centroids = {};\n    skmeansResult.centroids.forEach(function (coord, idx) {\n        centroids[idx] = coord;\n    });\n    // add associated cluster number\n    featureEach(points, function (point, index) {\n        var clusterId = skmeansResult.idxs[index];\n        point.properties.cluster = clusterId;\n        point.properties.centroid = centroids[clusterId];\n    });\n    return points;\n}\nexport default clustersKmeans;\n","var internalObjectKeys = require('../internals/object-keys-internal');\nvar enumBugKeys = require('../internals/enum-bug-keys');\n\n// `Object.keys` method\n// https://tc39.es/ecma262/#sec-object.keys\n// eslint-disable-next-line es/no-object-keys -- safe\nmodule.exports = Object.keys || function keys(O) {\n  return internalObjectKeys(O, enumBugKeys);\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar fails = require('../internals/fails');\nvar objectKeys = require('../internals/object-keys');\nvar getOwnPropertySymbolsModule = require('../internals/object-get-own-property-symbols');\nvar propertyIsEnumerableModule = require('../internals/object-property-is-enumerable');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\n\n// eslint-disable-next-line es/no-object-assign -- safe\nvar $assign = Object.assign;\n// eslint-disable-next-line es/no-object-defineproperty -- required for testing\nvar defineProperty = Object.defineProperty;\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\nmodule.exports = !$assign || fails(function () {\n  // should have correct order of operations (Edge bug)\n  if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, 'a', {\n    enumerable: true,\n    get: function () {\n      defineProperty(this, 'b', {\n        value: 3,\n        enumerable: false\n      });\n    }\n  }), { b: 2 })).b !== 1) return true;\n  // should work with symbols and should have deterministic property order (V8 bug)\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line es/no-symbol -- safe\n  var symbol = Symbol();\n  var alphabet = 'abcdefghijklmnopqrst';\n  A[symbol] = 7;\n  alphabet.split('').forEach(function (chr) { B[chr] = chr; });\n  return $assign({}, A)[symbol] != 7 || objectKeys($assign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`\n  var T = toObject(target);\n  var argumentsLength = arguments.length;\n  var index = 1;\n  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n  var propertyIsEnumerable = propertyIsEnumerableModule.f;\n  while (argumentsLength > index) {\n    var S = IndexedObject(arguments[index++]);\n    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) {\n      key = keys[j++];\n      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];\n    }\n  } return T;\n} : $assign;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","var $ = require('../internals/export');\nvar assign = require('../internals/object-assign');\n\n// `Object.assign` method\n// https://tc39.es/ecma262/#sec-object.assign\n// eslint-disable-next-line es/no-object-assign -- required for testing\n$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {\n  assign: assign\n});\n","/**\r\n * DBSCAN - Density based clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * DBSCAN class construcotr\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {DBSCAN}\r\n */\r\nfunction DBSCAN(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {Array} */\r\n  this.dataset = [];\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 2;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n  /** @type {Array} */\r\n  this.clusters = [];\r\n  /** @type {Array} */\r\n  this.noise = [];\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._visited = [];\r\n  /** @type {Array} */\r\n  this._assigned = [];\r\n  /** @type {number} */\r\n  this._datasetLength = 0;\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n};\r\n\r\n/******************************************************************************/\r\n// public functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nDBSCAN.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0; pointId < this._datasetLength; pointId++) {\r\n    // if point is not visited, check if it forms a cluster\r\n    if (this._visited[pointId] !== 1) {\r\n      this._visited[pointId] = 1;\r\n\r\n      // if closest neighborhood is too small to form a cluster, mark as noise\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      if (neighbors.length < this.minPts) {\r\n        this.noise.push(pointId);\r\n      } else {\r\n        // create new cluster and add point\r\n        var clusterId = this.clusters.length;\r\n        this.clusters.push([]);\r\n        this._addToCluster(pointId, clusterId);\r\n\r\n        this._expandCluster(clusterId, neighbors);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this.noise = [];\r\n\r\n    this._datasetLength = dataset.length;\r\n    this._visited = new Array(this._datasetLength);\r\n    this._assigned = new Array(this._datasetLength);\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Expand cluster to closest points of given neighborhood\r\n *\r\n * @param {number} clusterId\r\n * @param {Array} neighbors\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._expandCluster = function(clusterId, neighbors) {\r\n\r\n  /**\r\n   * It's very important to calculate length of neighbors array each time,\r\n   * as the number of elements changes over time\r\n   */\r\n  for (var i = 0; i < neighbors.length; i++) {\r\n    var pointId2 = neighbors[i];\r\n\r\n    if (this._visited[pointId2] !== 1) {\r\n      this._visited[pointId2] = 1;\r\n      var neighbors2 = this._regionQuery(pointId2);\r\n\r\n      if (neighbors2.length >= this.minPts) {\r\n        neighbors = this._mergeArrays(neighbors, neighbors2);\r\n      }\r\n    }\r\n\r\n    // add to cluster\r\n    if (this._assigned[pointId2] !== 1) {\r\n      this._addToCluster(pointId2, clusterId);\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Add new point to cluster\r\n *\r\n * @param {number} pointId\r\n * @param {number} clusterId\r\n */\r\nDBSCAN.prototype._addToCluster = function(pointId, clusterId) {\r\n  this.clusters[clusterId].push(pointId);\r\n  this._assigned[pointId] = 1;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId,\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._regionQuery = function(pointId) {\r\n  var neighbors = [];\r\n\r\n  for (var id = 0; id < this._datasetLength; id++) {\r\n    var dist = this.distance(this.dataset[pointId], this.dataset[id]);\r\n    if (dist < this.epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * @param {Array} a\r\n * @param {Array} b\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._mergeArrays = function(a, b) {\r\n  var len = b.length;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    var P = b[i];\r\n    if (a.indexOf(P) < 0) {\r\n      a.push(P);\r\n    }\r\n  }\r\n\r\n  return a;\r\n};\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nDBSCAN.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = DBSCAN;\r\n}\r\n","ï»¿/**\r\n * KMEANS clustering\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * KMEANS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} k - number of clusters\r\n * @param {function} distance - distance function\r\n * @returns {KMEANS}\r\n */\r\n function KMEANS(dataset, k, distance) {\r\n  this.k = 3; // number of clusters\r\n  this.dataset = []; // set of feature vectors\r\n  this.assignments = []; // set of associated clusters for each feature vector\r\n  this.centroids = []; // vectors for our clusters\r\n\r\n  this.init(dataset, k, distance);\r\n}\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.init = function(dataset, k, distance) {\r\n  this.assignments = [];\r\n  this.centroids = [];\r\n\r\n  if (typeof dataset !== 'undefined') {\r\n    this.dataset = dataset;\r\n  }\r\n\r\n  if (typeof k !== 'undefined') {\r\n    this.k = k;\r\n  }\r\n\r\n  if (typeof distance !== 'undefined') {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.run = function(dataset, k) {\r\n  this.init(dataset, k);\r\n\r\n  var len = this.dataset.length;\r\n\r\n  // initialize centroids\r\n  for (var i = 0; i < this.k; i++) {\r\n    this.centroids[i] = this.randomCentroid();\r\n\t}\r\n\r\n  var change = true;\r\n  while(change) {\r\n\r\n    // assign feature vectors to clusters\r\n    change = this.assign();\r\n\r\n    // adjust location of centroids\r\n    for (var centroidId = 0; centroidId < this.k; centroidId++) {\r\n      var mean = new Array(maxDim);\r\n      var count = 0;\r\n\r\n      // init mean vector\r\n      for (var dim = 0; dim < maxDim; dim++) {\r\n        mean[dim] = 0;\r\n      }\r\n\r\n      for (var j = 0; j < len; j++) {\r\n        var maxDim = this.dataset[j].length;\r\n\r\n        // if current cluster id is assigned to point\r\n        if (centroidId === this.assignments[j]) {\r\n          for (var dim = 0; dim < maxDim; dim++) {\r\n            mean[dim] += this.dataset[j][dim];\r\n          }\r\n          count++;\r\n        }\r\n      }\r\n\r\n      if (count > 0) {\r\n        // if cluster contain points, adjust centroid position\r\n        for (var dim = 0; dim < maxDim; dim++) {\r\n          mean[dim] /= count;\r\n        }\r\n        this.centroids[centroidId] = mean;\r\n      } else {\r\n        // if cluster is empty, generate new random centroid\r\n        this.centroids[centroidId] = this.randomCentroid();\r\n        change = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.getClusters();\r\n};\r\n\r\n/**\r\n * Generate random centroid\r\n *\r\n * @returns {Array}\r\n */\r\nKMEANS.prototype.randomCentroid = function() {\r\n  var maxId = this.dataset.length -1;\r\n  var centroid;\r\n  var id;\r\n\r\n  do {\r\n    id = Math.round(Math.random() * maxId);\r\n    centroid = this.dataset[id];\r\n  } while (this.centroids.indexOf(centroid) >= 0);\r\n\r\n  return centroid;\r\n}\r\n\r\n/**\r\n * Assign points to clusters\r\n *\r\n * @returns {boolean}\r\n */\r\nKMEANS.prototype.assign = function() {\r\n  var change = false;\r\n  var len = this.dataset.length;\r\n  var closestCentroid;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    closestCentroid = this.argmin(this.dataset[i], this.centroids, this.distance);\r\n\r\n    if (closestCentroid != this.assignments[i]) {\r\n      this.assignments[i] = closestCentroid;\r\n      change = true;\r\n    }\r\n  }\r\n\r\n  return change;\r\n}\r\n\r\n/**\r\n * Extract information about clusters\r\n *\r\n * @returns {undefined}\r\n */\r\nKMEANS.prototype.getClusters = function() {\r\n  var clusters = new Array(this.k);\r\n  var centroidId;\r\n\r\n  for (var pointId = 0; pointId < this.assignments.length; pointId++) {\r\n    centroidId = this.assignments[pointId];\r\n\r\n    // init empty cluster\r\n    if (typeof clusters[centroidId] === 'undefined') {\r\n      clusters[centroidId] = [];\r\n    }\r\n\r\n    clusters[centroidId].push(pointId);\r\n  }\r\n\r\n  return clusters;\r\n};\r\n\r\n// utils\r\n\r\n/**\r\n * @params {Array} point\r\n * @params {Array.<Array>} set\r\n * @params {Function} f\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.argmin = function(point, set, f) {\r\n  var min = Number.MAX_VALUE;\r\n  var arg = 0;\r\n  var len = set.length;\r\n  var d;\r\n\r\n  for (var i = 0; i < len; i++) {\r\n    d = f(point, set[i]);\r\n    if (d < min) {\r\n      min = d;\r\n      arg = i;\r\n    }\r\n  }\r\n\r\n  return arg;\r\n};\r\n\r\n/**\r\n * Euclidean distance\r\n *\r\n * @params {number} p\r\n * @params {number} q\r\n * @returns {number}\r\n */\r\nKMEANS.prototype.distance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    var diff = p[i] - q[i];\r\n    sum += diff * diff;\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = KMEANS;\r\n}\r\n","/**\r\n * PriorityQueue\r\n * Elements in this queue are sorted according to their value\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * PriorityQueue class construcotr\r\n * @constructor\r\n *\r\n * @example\r\n * queue: [1,2,3,4]\r\n * priorities: [4,1,2,3]\r\n * > result = [1,4,2,3]\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @param {string} sorting - asc / desc\r\n * @returns {PriorityQueue}\r\n */\r\nfunction PriorityQueue(elements, priorities, sorting) {\r\n  /** @type {Array} */\r\n  this._queue = [];\r\n  /** @type {Array} */\r\n  this._priorities = [];\r\n  /** @type {string} */\r\n  this._sorting = 'desc';\r\n\r\n  this._init(elements, priorities, sorting);\r\n};\r\n\r\n/**\r\n * Insert element\r\n *\r\n * @param {Object} ele\r\n * @param {Object} priority\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.insert = function(ele, priority) {\r\n  var indexToInsert = this._queue.length;\r\n  var index = indexToInsert;\r\n\r\n  while (index--) {\r\n    var priority2 = this._priorities[index];\r\n    if (this._sorting === 'desc') {\r\n      if (priority > priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    } else {\r\n      if (priority < priority2) {\r\n        indexToInsert = index;\r\n      }\r\n    }\r\n  }\r\n\r\n  this._insertAt(ele, priority, indexToInsert);\r\n};\r\n\r\n/**\r\n * Remove element\r\n *\r\n * @param {Object} ele\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.remove = function(ele) {\r\n  var index = this._queue.length;\r\n\r\n  while (index--) {\r\n    var ele2 = this._queue[index];\r\n    if (ele === ele2) {\r\n      this._queue.splice(index, 1);\r\n      this._priorities.splice(index, 1);\r\n      break;\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * For each loop wrapper\r\n *\r\n * @param {function} func\r\n * @returs {undefined}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.forEach = function(func) {\r\n  this._queue.forEach(func);\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElements = function() {\r\n  return this._queue;\r\n};\r\n\r\n/**\r\n * @param {number} index\r\n * @returns {Object}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementPriority = function(index) {\r\n  return this._priorities[index];\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getPriorities = function() {\r\n  return this._priorities;\r\n};\r\n\r\n/**\r\n * @returns {Array}\r\n * @access public\r\n */\r\nPriorityQueue.prototype.getElementsWithPriorities = function() {\r\n  var result = [];\r\n\r\n  for (var i = 0, l = this._queue.length; i < l; i++) {\r\n    result.push([this._queue[i], this._priorities[i]]);\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} elements\r\n * @param {Array} priorities\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._init = function(elements, priorities, sorting) {\r\n\r\n  if (elements && priorities) {\r\n    this._queue = [];\r\n    this._priorities = [];\r\n\r\n    if (elements.length !== priorities.length) {\r\n      throw new Error('Arrays must have the same length');\r\n    }\r\n\r\n    for (var i = 0; i < elements.length; i++) {\r\n      this.insert(elements[i], priorities[i]);\r\n    }\r\n  }\r\n\r\n  if (sorting) {\r\n    this._sorting = sorting;\r\n  }\r\n};\r\n\r\n/**\r\n * Insert element at given position\r\n *\r\n * @param {Object} ele\r\n * @param {number} index\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nPriorityQueue.prototype._insertAt = function(ele, priority, index) {\r\n  if (this._queue.length === index) {\r\n    this._queue.push(ele);\r\n    this._priorities.push(priority);\r\n  } else {\r\n    this._queue.splice(index, 0, ele);\r\n    this._priorities.splice(index, 0, priority);\r\n  }\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = PriorityQueue;\r\n}\r\n","\r\n/**\r\n * @requires ./PriorityQueue.js\r\n */\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n      var PriorityQueue = require('./PriorityQueue.js');\r\n}\r\n\r\n/**\r\n * OPTICS - Ordering points to identify the clustering structure\r\n *\r\n * @author Lukasz Krawczyk <contact@lukaszkrawczyk.eu>\r\n * @copyright MIT\r\n */\r\n\r\n/**\r\n * OPTICS class constructor\r\n * @constructor\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distanceFunction\r\n * @returns {OPTICS}\r\n */\r\nfunction OPTICS(dataset, epsilon, minPts, distanceFunction) {\r\n  /** @type {number} */\r\n  this.epsilon = 1;\r\n  /** @type {number} */\r\n  this.minPts = 1;\r\n  /** @type {function} */\r\n  this.distance = this._euclideanDistance;\r\n\r\n  // temporary variables used during computation\r\n\r\n  /** @type {Array} */\r\n  this._reachability = [];\r\n  /** @type {Array} */\r\n  this._processed = [];\r\n  /** @type {number} */\r\n  this._coreDistance = 0;\r\n  /** @type {Array} */\r\n  this._orderedList = [];\r\n\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n}\r\n\r\n/******************************************************************************/\r\n// pulic functions\r\n\r\n/**\r\n * Start clustering\r\n *\r\n * @param {Array} dataset\r\n * @returns {undefined}\r\n * @access public\r\n */\r\nOPTICS.prototype.run = function(dataset, epsilon, minPts, distanceFunction) {\r\n  this._init(dataset, epsilon, minPts, distanceFunction);\r\n\r\n  for (var pointId = 0, l = this.dataset.length; pointId < l; pointId++) {\r\n    if (this._processed[pointId] !== 1) {\r\n      this._processed[pointId] = 1;\r\n      this.clusters.push([pointId]);\r\n      var clusterId = this.clusters.length - 1;\r\n\r\n      this._orderedList.push(pointId);\r\n      var priorityQueue = new PriorityQueue(null, null, 'asc');\r\n      var neighbors = this._regionQuery(pointId);\r\n\r\n      // using priority queue assign elements to new cluster\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, priorityQueue);\r\n        this._expandCluster(clusterId, priorityQueue);\r\n      }\r\n    }\r\n  }\r\n\r\n  return this.clusters;\r\n};\r\n\r\n/**\r\n * Generate reachability plot for all points\r\n *\r\n * @returns {array}\r\n * @access public\r\n */\r\nOPTICS.prototype.getReachabilityPlot = function() {\r\n  var reachabilityPlot = [];\r\n\r\n  for (var i = 0, l = this._orderedList.length; i < l; i++) {\r\n    var pointId = this._orderedList[i];\r\n    var distance = this._reachability[pointId];\r\n\r\n    reachabilityPlot.push([pointId, distance]);\r\n  }\r\n\r\n  return reachabilityPlot;\r\n};\r\n\r\n/******************************************************************************/\r\n// protected functions\r\n\r\n/**\r\n * Set object properties\r\n *\r\n * @param {Array} dataset\r\n * @param {number} epsilon\r\n * @param {number} minPts\r\n * @param {function} distance\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._init = function(dataset, epsilon, minPts, distance) {\r\n\r\n  if (dataset) {\r\n\r\n    if (!(dataset instanceof Array)) {\r\n      throw Error('Dataset must be of type array, ' +\r\n        typeof dataset + ' given');\r\n    }\r\n\r\n    this.dataset = dataset;\r\n    this.clusters = [];\r\n    this._reachability = new Array(this.dataset.length);\r\n    this._processed = new Array(this.dataset.length);\r\n    this._coreDistance = 0;\r\n    this._orderedList = [];\r\n  }\r\n\r\n  if (epsilon) {\r\n    this.epsilon = epsilon;\r\n  }\r\n\r\n  if (minPts) {\r\n    this.minPts = minPts;\r\n  }\r\n\r\n  if (distance) {\r\n    this.distance = distance;\r\n  }\r\n};\r\n\r\n/**\r\n * Update information in queue\r\n *\r\n * @param {number} pointId\r\n * @param {Array} neighbors\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._updateQueue = function(pointId, neighbors, queue) {\r\n  var self = this;\r\n\r\n  this._coreDistance = this._distanceToCore(pointId);\r\n  neighbors.forEach(function(pointId2) {\r\n    if (self._processed[pointId2] === undefined) {\r\n      var dist = self.distance(self.dataset[pointId], self.dataset[pointId2]);\r\n      var newReachableDistance = Math.max(self._coreDistance, dist);\r\n\r\n      if (self._reachability[pointId2] === undefined) {\r\n        self._reachability[pointId2] = newReachableDistance;\r\n        queue.insert(pointId2, newReachableDistance);\r\n      } else {\r\n        if (newReachableDistance < self._reachability[pointId2]) {\r\n          self._reachability[pointId2] = newReachableDistance;\r\n          queue.remove(pointId2);\r\n          queue.insert(pointId2, newReachableDistance);\r\n        }\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\n/**\r\n * Expand cluster\r\n *\r\n * @param {number} clusterId\r\n * @param {PriorityQueue} queue\r\n * @returns {undefined}\r\n * @access protected\r\n */\r\nOPTICS.prototype._expandCluster = function(clusterId, queue) {\r\n  var queueElements = queue.getElements();\r\n\r\n  for (var p = 0, l = queueElements.length; p < l; p++) {\r\n    var pointId = queueElements[p];\r\n    if (this._processed[pointId] === undefined) {\r\n      var neighbors = this._regionQuery(pointId);\r\n      this._processed[pointId] = 1;\r\n\r\n      this.clusters[clusterId].push(pointId);\r\n      this._orderedList.push(pointId);\r\n\r\n      if (this._distanceToCore(pointId) !== undefined) {\r\n        this._updateQueue(pointId, neighbors, queue);\r\n        this._expandCluster(clusterId, queue);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Calculating distance to cluster core\r\n *\r\n * @param {number} pointId\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._distanceToCore = function(pointId) {\r\n  var l = this.epsilon;\r\n  for (var coreDistCand = 0; coreDistCand < l; coreDistCand++) {\r\n    var neighbors = this._regionQuery(pointId, coreDistCand);\r\n    if (neighbors.length >= this.minPts) {\r\n      return coreDistCand;\r\n    }\r\n  }\r\n\r\n  return;\r\n};\r\n\r\n/**\r\n * Find all neighbors around given point\r\n *\r\n * @param {number} pointId\r\n * @param {number} epsilon\r\n * @returns {Array}\r\n * @access protected\r\n */\r\nOPTICS.prototype._regionQuery = function(pointId, epsilon) {\r\n  epsilon = epsilon || this.epsilon;\r\n  var neighbors = [];\r\n\r\n  for (var id = 0, l = this.dataset.length; id < l; id++) {\r\n    if (this.distance(this.dataset[pointId], this.dataset[id]) < epsilon) {\r\n      neighbors.push(id);\r\n    }\r\n  }\r\n\r\n  return neighbors;\r\n};\r\n\r\n/******************************************************************************/\r\n// helpers\r\n\r\n/**\r\n * Calculate euclidean distance in multidimensional space\r\n *\r\n * @param {Array} p\r\n * @param {Array} q\r\n * @returns {number}\r\n * @access protected\r\n */\r\nOPTICS.prototype._euclideanDistance = function(p, q) {\r\n  var sum = 0;\r\n  var i = Math.min(p.length, q.length);\r\n\r\n  while (i--) {\r\n    sum += (p[i] - q[i]) * (p[i] - q[i]);\r\n  }\r\n\r\n  return Math.sqrt(sum);\r\n};\r\n\r\nif (typeof module !== 'undefined' && module.exports) {\r\n  module.exports = OPTICS;\r\n}\r\n","\r\nif (typeof module !== 'undefined' && module.exports) {\r\n    module.exports = {\r\n      DBSCAN: require('./DBSCAN.js'),\r\n      KMEANS: require('./KMEANS.js'),\r\n      OPTICS: require('./OPTICS.js'),\r\n      PriorityQueue: require('./PriorityQueue.js')\r\n    };\r\n}\r\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  AbstractViewportAlgorithm,\n  AlgorithmInput,\n  ViewportAlgorithmOptions,\n} from \"./core\";\nimport { Units, featureCollection, point } from \"@turf/helpers\";\n\nimport { Cluster } from \"../cluster\";\nimport clustersDbscan from \"@turf/clusters-dbscan\";\n\nexport interface DBScanOptions {\n  units?: Units;\n  minPoints?: number;\n  mutate?: boolean;\n}\n\nexport interface DBScanAlgorithmOptions extends ViewportAlgorithmOptions {\n  maxDistance?: number;\n  minPoints?: number;\n}\n\nconst DEFAULT_INTERNAL_DBSCAN_OPTION: DBScanOptions = {\n  units: \"kilometers\",\n  mutate: false,\n  minPoints: 1,\n};\n\n/**\n *\n * **This algorithm is not yet ready for use!**\n *\n * Experimental algorithm using DBScan.\n *\n * @see https://www.npmjs.com/package/@turf/clusters-dbscan\n */\nexport class DBScanAlgorithm extends AbstractViewportAlgorithm {\n  protected maxDistance: number;\n  protected options: DBScanOptions;\n  constructor({\n    maxDistance = 200,\n    minPoints = DEFAULT_INTERNAL_DBSCAN_OPTION.minPoints,\n    ...options\n  }: DBScanAlgorithmOptions) {\n    super(options);\n    this.maxDistance = maxDistance;\n    this.options = {\n      ...DEFAULT_INTERNAL_DBSCAN_OPTION,\n      minPoints,\n    };\n  }\n\n  protected cluster({\n    markers,\n    mapCanvasProjection,\n  }: AlgorithmInput): Cluster[] {\n    const points = featureCollection(\n      markers.map((marker) => {\n        const projectedPoint = mapCanvasProjection.fromLatLngToContainerPixel(\n          marker.getPosition()\n        );\n        return point([projectedPoint.x, projectedPoint.y]);\n      })\n    );\n\n    const grouped: google.maps.Marker[][] = [];\n\n    clustersDbscan(points, this.maxDistance, this.options).features.forEach(\n      (point, i) => {\n        if (!grouped[point.properties.cluster]) {\n          grouped[point.properties.cluster] = [];\n        }\n\n        grouped[point.properties.cluster].push(markers[i]);\n      }\n    );\n\n    return grouped.map((markers) => new Cluster({ markers }));\n  }\n}\n","import clone from \"@turf/clone\";\nimport distance from \"@turf/distance\";\nimport { coordAll } from \"@turf/meta\";\nimport { convertLength, } from \"@turf/helpers\";\nimport clustering from \"density-clustering\";\n/**\n * Takes a set of {@link Point|points} and partition them into clusters according to {@link DBSCAN's|https://en.wikipedia.org/wiki/DBSCAN} data clustering algorithm.\n *\n * @name clustersDbscan\n * @param {FeatureCollection<Point>} points to be clustered\n * @param {number} maxDistance Maximum Distance between any point of the cluster to generate the clusters (kilometers only)\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=\"kilometers\"] in which `maxDistance` is expressed, can be degrees, radians, miles, or kilometers\n * @param {boolean} [options.mutate=false] Allows GeoJSON input to be mutated\n * @param {number} [options.minPoints=3] Minimum number of points to generate a single cluster,\n * points which do not meet this requirement will be classified as an 'edge' or 'noise'.\n * @returns {FeatureCollection<Point>} Clustered Points with an additional two properties associated to each Feature:\n * - {number} cluster - the associated clusterId\n * - {string} dbscan - type of point it has been classified as ('core'|'edge'|'noise')\n * @example\n * // create random points with random z-values in their properties\n * var points = turf.randomPoint(100, {bbox: [0, 30, 20, 50]});\n * var maxDistance = 100;\n * var clustered = turf.clustersDbscan(points, maxDistance);\n *\n * //addToMap\n * var addToMap = [clustered];\n */\nfunction clustersDbscan(points, maxDistance, options) {\n    // Input validation being handled by Typescript\n    // collectionOf(points, 'Point', 'points must consist of a FeatureCollection of only Points');\n    // if (maxDistance === null || maxDistance === undefined) throw new Error('maxDistance is required');\n    // if (!(Math.sign(maxDistance) > 0)) throw new Error('maxDistance is invalid');\n    // if (!(minPoints === undefined || minPoints === null || Math.sign(minPoints) > 0)) throw new Error('options.minPoints is invalid');\n    if (options === void 0) { options = {}; }\n    // Clone points to prevent any mutations\n    if (options.mutate !== true)\n        points = clone(points);\n    // Defaults\n    options.minPoints = options.minPoints || 3;\n    // create clustered ids\n    var dbscan = new clustering.DBSCAN();\n    var clusteredIds = dbscan.run(coordAll(points), convertLength(maxDistance, options.units), options.minPoints, distance);\n    // Tag points to Clusters ID\n    var clusterId = -1;\n    clusteredIds.forEach(function (clusterIds) {\n        clusterId++;\n        // assign cluster ids to input points\n        clusterIds.forEach(function (idx) {\n            var clusterPoint = points.features[idx];\n            if (!clusterPoint.properties)\n                clusterPoint.properties = {};\n            clusterPoint.properties.cluster = clusterId;\n            clusterPoint.properties.dbscan = \"core\";\n        });\n    });\n    // handle noise points, if any\n    // edges points are tagged by DBSCAN as both 'noise' and 'cluster' as they can \"reach\" less than 'minPoints' number of points\n    dbscan.noise.forEach(function (noiseId) {\n        var noisePoint = points.features[noiseId];\n        if (!noisePoint.properties)\n            noisePoint.properties = {};\n        if (noisePoint.properties.cluster)\n            noisePoint.properties.dbscan = \"edge\";\n        else\n            noisePoint.properties.dbscan = \"noise\";\n    });\n    return points;\n}\nexport default clustersDbscan;\n","\nexport default function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) return;\n\n    const m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        const t = coords[2 * k + inc];\n        let i = left;\n        let j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) swapItem(ids, coords, left, right);\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) i++;\n            while (coords[2 * j + inc] > t) j--;\n        }\n\n        if (coords[2 * left + inc] === t) swapItem(ids, coords, left, j);\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n","\nexport default function within(ids, coords, qx, qy, r, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    const r2 = r * r;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        const x = coords[2 * m];\n        const y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    const dx = ax - bx;\n    const dy = ay - by;\n    return dx * dx + dy * dy;\n}\n","\nimport sort from './sort';\nimport range from './range';\nimport within from './within';\n\nconst defaultGetX = p => p[0];\nconst defaultGetY = p => p[1];\n\nexport default class KDBush {\n    constructor(points, getX = defaultGetX, getY = defaultGetY, nodeSize = 64, ArrayType = Float64Array) {\n        this.nodeSize = nodeSize;\n        this.points = points;\n\n        const IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n        const ids = this.ids = new IndexArrayType(points.length);\n        const coords = this.coords = new ArrayType(points.length * 2);\n\n        for (let i = 0; i < points.length; i++) {\n            ids[i] = i;\n            coords[2 * i] = getX(points[i]);\n            coords[2 * i + 1] = getY(points[i]);\n        }\n\n        sort(ids, coords, nodeSize, 0, ids.length - 1, 0);\n    }\n\n    range(minX, minY, maxX, maxY) {\n        return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n    }\n\n    within(x, y, r) {\n        return within(this.ids, this.coords, x, y, r, this.nodeSize);\n    }\n}\n","\nexport default function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    const stack = [0, ids.length - 1, 0];\n    const result = [];\n    let x, y;\n\n    while (stack.length) {\n        const axis = stack.pop();\n        const right = stack.pop();\n        const left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (let i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[i]);\n            }\n            continue;\n        }\n\n        const m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) result.push(ids[m]);\n\n        const nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n","\nimport KDBush from 'kdbush';\n\nconst defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: props => props // props => ({sum: props.my_value})\n};\n\nconst fround = Math.fround || (tmp => ((x) => { tmp[0] = +x; return tmp[0]; }))(new Float32Array(1));\n\nexport default class Supercluster {\n    constructor(options) {\n        this.options = extend(Object.create(defaultOptions), options);\n        this.trees = new Array(this.options.maxZoom + 1);\n    }\n\n    load(points) {\n        const {log, minZoom, maxZoom, nodeSize} = this.options;\n\n        if (log) console.time('total time');\n\n        const timerId = `prepare ${  points.length  } points`;\n        if (log) console.time(timerId);\n\n        this.points = points;\n\n        // generate a cluster object for each point and index input points into a KD-tree\n        let clusters = [];\n        for (let i = 0; i < points.length; i++) {\n            if (!points[i].geometry) continue;\n            clusters.push(createPointCluster(points[i], i));\n        }\n        this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) console.timeEnd(timerId);\n\n        // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n        // results in a cluster hierarchy across zoom levels\n        for (let z = maxZoom; z >= minZoom; z--) {\n            const now = +Date.now();\n\n            // create a new set of clusters for the zoom and index them with a KD-tree\n            clusters = this._cluster(clusters, z);\n            this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n            if (log) console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n        }\n\n        if (log) console.timeEnd('total time');\n\n        return this;\n    }\n\n    getClusters(bbox, zoom) {\n        let minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n        const minLat = Math.max(-90, Math.min(90, bbox[1]));\n        let maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n        const maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n        if (bbox[2] - bbox[0] >= 360) {\n            minLng = -180;\n            maxLng = 180;\n        } else if (minLng > maxLng) {\n            const easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n            const westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n            return easternHem.concat(westernHem);\n        }\n\n        const tree = this.trees[this._limitZoom(zoom)];\n        const ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n        const clusters = [];\n        for (const id of ids) {\n            const c = tree.points[id];\n            clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n        return clusters;\n    }\n\n    getChildren(clusterId) {\n        const originId = this._getOriginId(clusterId);\n        const originZoom = this._getOriginZoom(clusterId);\n        const errorMsg = 'No cluster with the specified id.';\n\n        const index = this.trees[originZoom];\n        if (!index) throw new Error(errorMsg);\n\n        const origin = index.points[originId];\n        if (!origin) throw new Error(errorMsg);\n\n        const r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n        const ids = index.within(origin.x, origin.y, r);\n        const children = [];\n        for (const id of ids) {\n            const c = index.points[id];\n            if (c.parentId === clusterId) {\n                children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n            }\n        }\n\n        if (children.length === 0) throw new Error(errorMsg);\n\n        return children;\n    }\n\n    getLeaves(clusterId, limit, offset) {\n        limit = limit || 10;\n        offset = offset || 0;\n\n        const leaves = [];\n        this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n        return leaves;\n    }\n\n    getTile(z, x, y) {\n        const tree = this.trees[this._limitZoom(z)];\n        const z2 = Math.pow(2, z);\n        const {extent, radius} = this.options;\n        const p = radius / extent;\n        const top = (y - p) / z2;\n        const bottom = (y + 1 + p) / z2;\n\n        const tile = {\n            features: []\n        };\n\n        this._addTileFeatures(\n            tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n            tree.points, x, y, z2, tile);\n\n        if (x === 0) {\n            this._addTileFeatures(\n                tree.range(1 - p / z2, top, 1, bottom),\n                tree.points, z2, y, z2, tile);\n        }\n        if (x === z2 - 1) {\n            this._addTileFeatures(\n                tree.range(0, top, p / z2, bottom),\n                tree.points, -1, y, z2, tile);\n        }\n\n        return tile.features.length ? tile : null;\n    }\n\n    getClusterExpansionZoom(clusterId) {\n        let expansionZoom = this._getOriginZoom(clusterId) - 1;\n        while (expansionZoom <= this.options.maxZoom) {\n            const children = this.getChildren(clusterId);\n            expansionZoom++;\n            if (children.length !== 1) break;\n            clusterId = children[0].properties.cluster_id;\n        }\n        return expansionZoom;\n    }\n\n    _appendLeaves(result, clusterId, limit, offset, skipped) {\n        const children = this.getChildren(clusterId);\n\n        for (const child of children) {\n            const props = child.properties;\n\n            if (props && props.cluster) {\n                if (skipped + props.point_count <= offset) {\n                    // skip the whole cluster\n                    skipped += props.point_count;\n                } else {\n                    // enter the cluster\n                    skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                    // exit the cluster\n                }\n            } else if (skipped < offset) {\n                // skip a single point\n                skipped++;\n            } else {\n                // add a single point\n                result.push(child);\n            }\n            if (result.length === limit) break;\n        }\n\n        return skipped;\n    }\n\n    _addTileFeatures(ids, points, x, y, z2, tile) {\n        for (const i of ids) {\n            const c = points[i];\n            const isCluster = c.numPoints;\n\n            let tags, px, py;\n            if (isCluster) {\n                tags = getClusterProperties(c);\n                px = c.x;\n                py = c.y;\n            } else {\n                const p = this.points[c.index];\n                tags = p.properties;\n                px = lngX(p.geometry.coordinates[0]);\n                py = latY(p.geometry.coordinates[1]);\n            }\n\n            const f = {\n                type: 1,\n                geometry: [[\n                    Math.round(this.options.extent * (px * z2 - x)),\n                    Math.round(this.options.extent * (py * z2 - y))\n                ]],\n                tags\n            };\n\n            // assign id\n            let id;\n            if (isCluster) {\n                id = c.id;\n            } else if (this.options.generateId) {\n                // optionally generate id\n                id = c.index;\n            } else if (this.points[c.index].id) {\n                // keep id if already assigned\n                id = this.points[c.index].id;\n            }\n\n            if (id !== undefined) f.id = id;\n\n            tile.features.push(f);\n        }\n    }\n\n    _limitZoom(z) {\n        return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n    }\n\n    _cluster(points, zoom) {\n        const clusters = [];\n        const {radius, extent, reduce, minPoints} = this.options;\n        const r = radius / (extent * Math.pow(2, zoom));\n\n        // loop through each point\n        for (let i = 0; i < points.length; i++) {\n            const p = points[i];\n            // if we've already visited the point at this zoom level, skip it\n            if (p.zoom <= zoom) continue;\n            p.zoom = zoom;\n\n            // find all nearby points\n            const tree = this.trees[zoom + 1];\n            const neighborIds = tree.within(p.x, p.y, r);\n\n            const numPointsOrigin = p.numPoints || 1;\n            let numPoints = numPointsOrigin;\n\n            // count the number of points in a potential cluster\n            for (const neighborId of neighborIds) {\n                const b = tree.points[neighborId];\n                // filter out neighbors that are already processed\n                if (b.zoom > zoom) numPoints += b.numPoints || 1;\n            }\n\n            if (numPoints >= minPoints) { // enough points to form a cluster\n                let wx = p.x * numPointsOrigin;\n                let wy = p.y * numPointsOrigin;\n\n                let clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n                // encode both zoom and point index on which the cluster originated -- offset by total length of features\n                const id = (i << 5) + (zoom + 1) + this.points.length;\n\n                for (const neighborId of neighborIds) {\n                    const b = tree.points[neighborId];\n\n                    if (b.zoom <= zoom) continue;\n                    b.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                    const numPoints2 = b.numPoints || 1;\n                    wx += b.x * numPoints2; // accumulate coordinates for calculating weighted center\n                    wy += b.y * numPoints2;\n\n                    b.parentId = id;\n\n                    if (reduce) {\n                        if (!clusterProperties) clusterProperties = this._map(p, true);\n                        reduce(clusterProperties, this._map(b));\n                    }\n                }\n\n                p.parentId = id;\n                clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n            } else { // left points as unclustered\n                clusters.push(p);\n\n                if (numPoints > 1) {\n                    for (const neighborId of neighborIds) {\n                        const b = tree.points[neighborId];\n                        if (b.zoom <= zoom) continue;\n                        b.zoom = zoom;\n                        clusters.push(b);\n                    }\n                }\n            }\n        }\n\n        return clusters;\n    }\n\n    // get index of the point from which the cluster originated\n    _getOriginId(clusterId) {\n        return (clusterId - this.points.length) >> 5;\n    }\n\n    // get zoom of the point from which the cluster originated\n    _getOriginZoom(clusterId) {\n        return (clusterId - this.points.length) % 32;\n    }\n\n    _map(point, clone) {\n        if (point.numPoints) {\n            return clone ? extend({}, point.properties) : point.properties;\n        }\n        const original = this.points[point.index].properties;\n        const result = this.options.map(original);\n        return clone && result === original ? extend({}, result) : result;\n    }\n}\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints,\n        properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    const [x, y] = p.geometry.coordinates;\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    const count = cluster.numPoints;\n    const abbrev =\n        count >= 10000 ? `${Math.round(count / 1000)  }k` :\n        count >= 1000 ? `${Math.round(count / 100) / 10  }k` : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    const sin = Math.sin(lat * Math.PI / 180);\n    const y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    const y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (const id in src) dest[id] = src[id];\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { AbstractAlgorithm, AlgorithmInput } from \"./core\";\nimport SuperCluster, { ClusterFeature } from \"supercluster\";\n\nimport { Cluster } from \"../cluster\";\nimport equal from \"fast-deep-equal/es6\";\n\nexport type SuperClusterOptions = SuperCluster.Options<\n  { [name: string]: any },\n  { [name: string]: any }\n>;\n\n/**\n * A very fast JavaScript algorithm for geospatial point clustering using KD trees.\n *\n * @see https://www.npmjs.com/package/supercluster for more information on options.\n */\nexport class SuperClusterAlgorithm extends AbstractAlgorithm {\n  protected superCluster: SuperCluster;\n  protected markers: google.maps.Marker[];\n  constructor({ maxZoom, ...options }: SuperClusterOptions) {\n    super({ maxZoom });\n\n    this.superCluster = new SuperCluster({\n      maxZoom: this.maxZoom,\n      radius: 60,\n      ...options,\n    });\n  }\n  public calculate(input: AlgorithmInput): Cluster[] {\n    if (!equal(input.markers, this.markers)) {\n      this.markers = input.markers;\n\n      const points = this.markers.map((marker) => {\n        return {\n          type: \"Feature\" as const,\n          geometry: {\n            type: \"Point\" as const,\n            coordinates: [\n              marker.getPosition().lng(),\n              marker.getPosition().lat(),\n            ],\n          },\n          properties: { marker },\n        };\n      });\n\n      this.superCluster.load(points);\n    }\n    return this.cluster(input);\n  }\n\n  public cluster({ map }: AlgorithmInput): Cluster[] {\n    const { west, south, east, north } = map.getBounds().toJSON();\n    return this.superCluster\n      .getClusters([west, south, east, north], map.getZoom())\n      .map(this.transformCluster.bind(this));\n  }\n\n  protected transformCluster({\n    geometry: {\n      coordinates: [lng, lat],\n    },\n    properties,\n  }: ClusterFeature<{ marker: google.maps.Marker }>): Cluster {\n    if (properties.cluster) {\n      return new Cluster({\n        markers: this.superCluster\n          .getLeaves(properties.cluster_id, Infinity)\n          .map((leaf) => leaf.properties.marker),\n        position: new google.maps.LatLng({ lat, lng }),\n      });\n    } else {\n      const marker = properties.marker;\n\n      return new Cluster({\n        markers: [marker],\n        position: marker.getPosition(),\n      });\n    }\n  }\n}\n","'use strict';\n/* eslint-disable es/no-array-prototype-indexof -- required for testing */\nvar $ = require('../internals/export');\nvar $indexOf = require('../internals/array-includes').indexOf;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\n\nvar nativeIndexOf = [].indexOf;\n\nvar NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;\nvar STRICT_METHOD = arrayMethodIsStrict('indexOf');\n\n// `Array.prototype.indexOf` method\n// https://tc39.es/ecma262/#sec-array.prototype.indexof\n$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? nativeIndexOf.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n","'use strict';\nvar toPrimitive = require('../internals/to-primitive');\nvar definePropertyModule = require('../internals/object-define-property');\nvar createPropertyDescriptor = require('../internals/create-property-descriptor');\n\nmodule.exports = function (object, key, value) {\n  var propertyKey = toPrimitive(key);\n  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n  else object[propertyKey] = value;\n};\n","'use strict';\nvar $ = require('../internals/export');\nvar toAbsoluteIndex = require('../internals/to-absolute-index');\nvar toInteger = require('../internals/to-integer');\nvar toLength = require('../internals/to-length');\nvar toObject = require('../internals/to-object');\nvar arraySpeciesCreate = require('../internals/array-species-create');\nvar createProperty = require('../internals/create-property');\nvar arrayMethodHasSpeciesSupport = require('../internals/array-method-has-species-support');\n\nvar HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');\n\nvar max = Math.max;\nvar min = Math.min;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';\n\n// `Array.prototype.splice` method\n// https://tc39.es/ecma262/#sec-array.prototype.splice\n// with adding support of @@species\n$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {\n  splice: function splice(start, deleteCount /* , ...items */) {\n    var O = toObject(this);\n    var len = toLength(O.length);\n    var actualStart = toAbsoluteIndex(start, len);\n    var argumentsLength = arguments.length;\n    var insertCount, actualDeleteCount, A, k, from, to;\n    if (argumentsLength === 0) {\n      insertCount = actualDeleteCount = 0;\n    } else if (argumentsLength === 1) {\n      insertCount = 0;\n      actualDeleteCount = len - actualStart;\n    } else {\n      insertCount = argumentsLength - 2;\n      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);\n    }\n    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {\n      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);\n    }\n    A = arraySpeciesCreate(O, actualDeleteCount);\n    for (k = 0; k < actualDeleteCount; k++) {\n      from = actualStart + k;\n      if (from in O) createProperty(A, k, O[from]);\n    }\n    A.length = actualDeleteCount;\n    if (insertCount < actualDeleteCount) {\n      for (k = actualStart; k < len - actualDeleteCount; k++) {\n        from = k + actualDeleteCount;\n        to = k + insertCount;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];\n    } else if (insertCount > actualDeleteCount) {\n      for (k = len - actualDeleteCount; k > actualStart; k--) {\n        from = k + actualDeleteCount - 1;\n        to = k + insertCount - 1;\n        if (from in O) O[to] = O[from];\n        else delete O[to];\n      }\n    }\n    for (k = 0; k < insertCount; k++) {\n      O[k + actualStart] = arguments[k + 2];\n    }\n    O.length = len - actualDeleteCount + insertCount;\n    return A;\n  }\n});\n","var isObject = require('../internals/is-object');\n\nmodule.exports = function (it) {\n  if (!isObject(it) && it !== null) {\n    throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n  } return it;\n};\n","var anObject = require('../internals/an-object');\nvar defineProperties = require('../internals/object-define-properties');\nvar enumBugKeys = require('../internals/enum-bug-keys');\nvar hiddenKeys = require('../internals/hidden-keys');\nvar html = require('../internals/html');\nvar documentCreateElement = require('../internals/document-create-element');\nvar sharedKey = require('../internals/shared-key');\n\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\n\nvar EmptyConstructor = function () { /* empty */ };\n\nvar scriptTag = function (content) {\n  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\n\n// Create object with fake `null` prototype: use ActiveX Object with cleared prototype\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n  activeXDocument.write(scriptTag(''));\n  activeXDocument.close();\n  var temp = activeXDocument.parentWindow.Object;\n  activeXDocument = null; // avoid memory leak\n  return temp;\n};\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar NullProtoObjectViaIFrame = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = documentCreateElement('iframe');\n  var JS = 'java' + SCRIPT + ':';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  html.appendChild(iframe);\n  // https://github.com/zloirock/core-js/issues/475\n  iframe.src = String(JS);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(scriptTag('document.F=Object'));\n  iframeDocument.close();\n  return iframeDocument.F;\n};\n\n// Check for document.domain and active x support\n// No need to use active x approach when document.domain is not set\n// see https://github.com/es-shims/es5-shim/issues/150\n// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346\n// avoid IE GC bug\nvar activeXDocument;\nvar NullProtoObject = function () {\n  try {\n    /* global ActiveXObject -- old IE */\n    activeXDocument = document.domain && new ActiveXObject('htmlfile');\n  } catch (error) { /* ignore */ }\n  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n  var length = enumBugKeys.length;\n  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n  return NullProtoObject();\n};\n\nhiddenKeys[IE_PROTO] = true;\n\n// `Object.create` method\n// https://tc39.es/ecma262/#sec-object.create\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    EmptyConstructor[PROTOTYPE] = anObject(O);\n    result = new EmptyConstructor();\n    EmptyConstructor[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = NullProtoObject();\n  return Properties === undefined ? result : defineProperties(result, Properties);\n};\n","/* eslint-disable no-proto -- safe */\nvar anObject = require('../internals/an-object');\nvar aPossiblePrototype = require('../internals/a-possible-prototype');\n\n// `Object.setPrototypeOf` method\n// https://tc39.es/ecma262/#sec-object.setprototypeof\n// Works with __proto__ only. Old v8 can't work with null proto objects.\n// eslint-disable-next-line es/no-object-setprototypeof -- safe\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n  var CORRECT_SETTER = false;\n  var test = {};\n  var setter;\n  try {\n    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe\n    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n    setter.call(test, []);\n    CORRECT_SETTER = test instanceof Array;\n  } catch (error) { /* empty */ }\n  return function setPrototypeOf(O, proto) {\n    anObject(O);\n    aPossiblePrototype(proto);\n    if (CORRECT_SETTER) setter.call(O, proto);\n    else O.__proto__ = proto;\n    return O;\n  };\n}() : undefined);\n","var isObject = require('../internals/is-object');\nvar setPrototypeOf = require('../internals/object-set-prototype-of');\n\n// makes subclassing work correct for wrapped built-ins\nmodule.exports = function ($this, dummy, Wrapper) {\n  var NewTarget, NewTargetPrototype;\n  if (\n    // it can work only with native `setPrototypeOf`\n    setPrototypeOf &&\n    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this\n    typeof (NewTarget = dummy.constructor) == 'function' &&\n    NewTarget !== Wrapper &&\n    isObject(NewTargetPrototype = NewTarget.prototype) &&\n    NewTargetPrototype !== Wrapper.prototype\n  ) setPrototypeOf($this, NewTargetPrototype);\n  return $this;\n};\n","var DESCRIPTORS = require('../internals/descriptors');\nvar definePropertyModule = require('../internals/object-define-property');\nvar anObject = require('../internals/an-object');\nvar objectKeys = require('../internals/object-keys');\n\n// `Object.defineProperties` method\n// https://tc39.es/ecma262/#sec-object.defineproperties\n// eslint-disable-next-line es/no-object-defineproperties -- safe\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = objectKeys(Properties);\n  var length = keys.length;\n  var index = 0;\n  var key;\n  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);\n  return O;\n};\n","var getBuiltIn = require('../internals/get-built-in');\n\nmodule.exports = getBuiltIn('document', 'documentElement');\n","var requireObjectCoercible = require('../internals/require-object-coercible');\nvar whitespaces = require('../internals/whitespaces');\n\nvar whitespace = '[' + whitespaces + ']';\nvar ltrim = RegExp('^' + whitespace + whitespace + '*');\nvar rtrim = RegExp(whitespace + whitespace + '*$');\n\n// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation\nvar createMethod = function (TYPE) {\n  return function ($this) {\n    var string = String(requireObjectCoercible($this));\n    if (TYPE & 1) string = string.replace(ltrim, '');\n    if (TYPE & 2) string = string.replace(rtrim, '');\n    return string;\n  };\n};\n\nmodule.exports = {\n  // `String.prototype.{ trimLeft, trimStart }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimstart\n  start: createMethod(1),\n  // `String.prototype.{ trimRight, trimEnd }` methods\n  // https://tc39.es/ecma262/#sec-string.prototype.trimend\n  end: createMethod(2),\n  // `String.prototype.trim` method\n  // https://tc39.es/ecma262/#sec-string.prototype.trim\n  trim: createMethod(3)\n};\n","'use strict';\nvar DESCRIPTORS = require('../internals/descriptors');\nvar global = require('../internals/global');\nvar isForced = require('../internals/is-forced');\nvar redefine = require('../internals/redefine');\nvar has = require('../internals/has');\nvar classof = require('../internals/classof-raw');\nvar inheritIfRequired = require('../internals/inherit-if-required');\nvar toPrimitive = require('../internals/to-primitive');\nvar fails = require('../internals/fails');\nvar create = require('../internals/object-create');\nvar getOwnPropertyNames = require('../internals/object-get-own-property-names').f;\nvar getOwnPropertyDescriptor = require('../internals/object-get-own-property-descriptor').f;\nvar defineProperty = require('../internals/object-define-property').f;\nvar trim = require('../internals/string-trim').trim;\n\nvar NUMBER = 'Number';\nvar NativeNumber = global[NUMBER];\nvar NumberPrototype = NativeNumber.prototype;\n\n// Opera ~12 has broken Object#toString\nvar BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;\n\n// `ToNumber` abstract operation\n// https://tc39.es/ecma262/#sec-tonumber\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  var first, third, radix, maxCode, digits, length, index, code;\n  if (typeof it == 'string' && it.length > 2) {\n    it = trim(it);\n    first = it.charCodeAt(0);\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i\n        default: return +it;\n      }\n      digits = it.slice(2);\n      length = digits.length;\n      for (index = 0; index < length; index++) {\n        code = digits.charCodeAt(index);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\n// `Number` constructor\n// https://tc39.es/ecma262/#sec-number-constructor\nif (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {\n  var NumberWrapper = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var dummy = this;\n    return dummy instanceof NumberWrapper\n      // check on 1..constructor(foo) case\n      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)\n        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);\n  };\n  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES2015 (in case, if modules with ES2015 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +\n    // ESNext\n    'fromString,range'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {\n      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));\n    }\n  }\n  NumberWrapper.prototype = NumberPrototype;\n  NumberPrototype.constructor = NumberWrapper;\n  redefine(global, NUMBER, NumberWrapper);\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Cluster } from \"./cluster\";\n\n/**\n * Provides statistics on all clusters in the current render cycle for use in {@link Renderer.render}.\n */\nexport class ClusterStats {\n  public readonly markers: { sum: number };\n  public readonly clusters: {\n    count: number;\n    markers: {\n      mean: number;\n      sum: number;\n      min: number;\n      max: number;\n    };\n  };\n\n  constructor(markers: google.maps.Marker[], clusters: Cluster[]) {\n    this.markers = { sum: markers.length };\n\n    const clusterMarkerCounts = clusters.map((a) => a.count);\n    const clusterMarkerSum = clusterMarkerCounts.reduce((a, b) => a + b, 0);\n\n    this.clusters = {\n      count: clusters.length,\n      markers: {\n        mean: clusterMarkerSum / clusters.length,\n        sum: clusterMarkerSum,\n        min: Math.min(...clusterMarkerCounts),\n        max: Math.max(...clusterMarkerCounts),\n      },\n    };\n  }\n}\n\nexport interface Renderer {\n  /**\n   * Turn a {@link Cluster} into a `google.maps.Marker`.\n   *\n   * Below is a simple example to create a marker with the number of markers in the cluster as a label.\n   *\n   * ```typescript\n   * return new google.maps.Marker({\n   *   position,\n   *   label: String(markers.length),\n   * });\n   * ```\n   */\n  render(cluster: Cluster, stats: ClusterStats): google.maps.Marker;\n}\n\nexport class DefaultRenderer implements Renderer {\n  /**\n   * The default render function for the library used by {@link MarkerClusterer}.\n   *\n   * Currently set to use the following:\n   *\n   * ```typescript\n   * // change color if this cluster has more markers than the mean cluster\n   * const color =\n   *   count > Math.max(10, stats.clusters.markers.mean)\n   *     ? \"#ff0000\"\n   *     : \"#0000ff\";\n   *\n   * // create svg url with fill color\n   * const svg = window.btoa(`\n   * <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n   *   <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n   * </svg>`);\n   *\n   * // create marker using svg icon\n   * return new google.maps.Marker({\n   *   position,\n   *   icon: {\n   *     url: `data:image/svg+xml;base64,${svg}`,\n   *     scaledSize: new google.maps.Size(45, 45),\n   *   },\n   *   label: {\n   *     text: String(count),\n   *     color: \"rgba(255,255,255,0.9)\",\n   *     fontSize: \"12px\",\n   *   },\n   *   // adjust zIndex to be above other markers\n   *   zIndex: 1000 + count,\n   * });\n   * ```\n   */\n  public render(\n    { count, position }: Cluster,\n    stats: ClusterStats\n  ): google.maps.Marker {\n    // change color if this cluster has more markers than the mean cluster\n    const color =\n      count > Math.max(10, stats.clusters.markers.mean) ? \"#ff0000\" : \"#0000ff\";\n\n    // create svg url with fill color\n    const svg = window.btoa(`\n  <svg fill=\"${color}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 240 240\">\n    <circle cx=\"120\" cy=\"120\" opacity=\".6\" r=\"70\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".3\" r=\"90\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".2\" r=\"110\" />\n    <circle cx=\"120\" cy=\"120\" opacity=\".1\" r=\"130\" />\n  </svg>`);\n\n    // create marker using svg icon\n    return new google.maps.Marker({\n      position,\n      icon: {\n        url: `data:image/svg+xml;base64,${svg}`,\n        scaledSize: new google.maps.Size(45, 45),\n      },\n      label: {\n        text: String(count),\n        color: \"rgba(255,255,255,0.9)\",\n        fontSize: \"12px\",\n      },\n      // adjust zIndex to be above other markers\n      zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n    });\n  }\n}\n","/**\n * Copyright 2021 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Algorithm, SuperClusterAlgorithm } from \"./algorithms\";\nimport { ClusterStats, DefaultRenderer, Renderer } from \"./renderer\";\n\nimport { Cluster } from \"./cluster\";\nimport { OverlayViewSafe } from \"./overlay-view-safe\";\n\nexport type onClusterClickHandler = (\n  event: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n) => void;\nexport interface MarkerClustererOptions {\n  markers?: google.maps.Marker[];\n  /**\n   * An algorithm to cluster markers. Default is {@link GridAlgorithm}. Must\n   * provide a `calculate` method accepting {@link AlgorithmInput} and returning\n   * an arry of {@link Cluster}.\n   */\n  algorithm?: Algorithm;\n  map?: google.maps.Map | null;\n  /**\n   * An object that converts a {@link Cluster} into a `google.maps.Marker`.\n   * Default is {@link DefaultRenderer}.\n   */\n  renderer?: Renderer;\n  onClusterClick?: onClusterClickHandler;\n}\n\nexport enum MarkerClustererEvents {\n  CLUSTERING_BEGIN = \"clusteringbegin\",\n  CLUSTERING_END = \"clusteringend\",\n  CLUSTER_CLICK = \"click\",\n}\n\nexport const defaultOnClusterClickHandler: onClusterClickHandler = (\n  _: google.maps.MapMouseEvent,\n  cluster: Cluster,\n  map: google.maps.Map\n): void => {\n  map.fitBounds(cluster.bounds);\n};\n/**\n * MarkerClusterer creates and manages per-zoom-level clusters for large amounts\n * of markers. See {@link MarkerClustererOptions} for more details.\n *\n * <iframe src=\"https://googlemaps.github.io/js-three/public/anchor/index.html\"></iframe>\n */\nexport class MarkerClusterer extends OverlayViewSafe {\n  /** @see {@link MarkerClustererOptions.onClusterClick} */\n  public onClusterClick: onClusterClickHandler;\n  /** @see {@link MarkerClustererOptions.algorithm} */\n  protected algorithm: Algorithm;\n  protected clusters: Cluster[];\n  protected markers: google.maps.Marker[];\n  /** @see {@link MarkerClustererOptions.renderer} */\n  protected renderer: Renderer;\n  /** @see {@link MarkerClustererOptions.map} */\n  protected map: google.maps.Map | null;\n  /** @see {@link MarkerClustererOptions.maxZoom} */\n  protected idleListener: google.maps.MapsEventListener;\n\n  constructor({\n    map,\n    markers = [],\n    algorithm = new SuperClusterAlgorithm({}),\n    renderer = new DefaultRenderer(),\n    onClusterClick = defaultOnClusterClickHandler,\n  }: MarkerClustererOptions) {\n    super();\n    this.markers = markers;\n    this.clusters = [];\n\n    this.algorithm = algorithm;\n    this.renderer = renderer;\n\n    this.onClusterClick = onClusterClick;\n\n    if (map) {\n      this.setMap(map);\n    }\n  }\n\n  public addMarker(marker: google.maps.Marker, noDraw?: boolean): void {\n    this.markers.push(marker);\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public addMarkers(markers: google.maps.Marker[], noDraw?: boolean): void {\n    markers.forEach((marker) => {\n      this.addMarker(marker, true);\n    });\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  public removeMarker(marker: google.maps.Marker, noDraw?: boolean): boolean {\n    const index = this.markers.indexOf(marker);\n\n    if (index === -1) {\n      // Marker is not in our list of markers, so do nothing:\n      return false;\n    }\n\n    marker.setMap(null);\n    this.markers.splice(index, 1); // Remove the marker from the list of managed markers\n\n    if (!noDraw) {\n      this.render();\n    }\n\n    return true;\n  }\n\n  public removeMarkers(\n    markers: google.maps.Marker[],\n    noDraw?: boolean\n  ): boolean {\n    let removed = false;\n\n    markers.forEach((marker) => {\n      removed = removed || this.removeMarker(marker, true);\n    });\n\n    if (removed && !noDraw) {\n      this.render();\n    }\n\n    return removed;\n  }\n\n  public clearMarkers(noDraw?: boolean): void {\n    this.markers.forEach((marker) => this.removeMarker(marker, true));\n\n    if (!noDraw) {\n      this.render();\n    }\n  }\n\n  /**\n   * Recalculates and draws all the marker clusters.\n   */\n  public render(): void {\n    const map = this.getMap();\n    if (map instanceof google.maps.Map && this.getProjection()) {\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_BEGIN,\n        this\n      );\n      const clusters = this.algorithm.calculate({\n        markers: this.markers,\n        map,\n        mapCanvasProjection: this.getProjection(),\n      });\n\n      // reset visibility of markers and clusters\n      this.reset();\n\n      // store new clusters\n      this.clusters = clusters;\n\n      this.renderClusters();\n      google.maps.event.trigger(\n        this,\n        MarkerClustererEvents.CLUSTERING_END,\n        this\n      );\n    }\n  }\n\n  public onAdd(): void {\n    this.idleListener = this.getMap().addListener(\n      \"idle\",\n      this.render.bind(this)\n    );\n    this.render();\n  }\n\n  public onRemove(): void {\n    google.maps.event.removeListener(this.idleListener);\n    this.reset();\n  }\n\n  protected reset(): void {\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.markers.forEach((marker) => marker.setMap(null));\n    this.clusters.forEach((cluster) => cluster.delete());\n    this.clusters = [];\n  }\n\n  protected renderClusters(): void {\n    // generate stats to pass to renderers\n    const stats = new ClusterStats(this.markers, this.clusters);\n    const map = this.getMap() as google.maps.Map;\n\n    this.clusters.forEach((cluster) => {\n      if (cluster.markers.length === 1) {\n        cluster.marker = cluster.markers[0];\n      } else {\n        cluster.marker = this.renderer.render(cluster, stats);\n\n        if (this.onClusterClick) {\n          cluster.marker.addListener(\n            \"click\",\n            /* istanbul ignore next */\n            (event: google.maps.MapMouseEvent) => {\n              google.maps.event.trigger(\n                this,\n                MarkerClustererEvents.CLUSTER_CLICK,\n                cluster\n              );\n              this.onClusterClick(event, cluster, map);\n            }\n          );\n        }\n      }\n\n      cluster.marker.setMap(map);\n    });\n  }\n}\n","/**\n * Copyright 2019 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface OverlayViewSafe extends google.maps.OverlayView {}\n\n/**\n * Extends an object's prototype by another's.\n *\n * @param type1 The Type to be extended.\n * @param type2 The Type to extend with.\n * @ignore\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction extend(type1: any, type2: any): void {\n  /* istanbul ignore next */\n  // eslint-disable-next-line prefer-const\n  for (let property in type2.prototype) {\n    type1.prototype[property] = type2.prototype[property];\n  }\n}\n\n/**\n * @ignore\n */\nexport class OverlayViewSafe {\n  constructor() {\n    // MarkerClusterer implements google.maps.OverlayView interface. We use the\n    // extend function to extend MarkerClusterer with google.maps.OverlayView\n    // because it might not always be available when the code is defined so we\n    // look for it at the last possible moment. If it doesn't exist now then\n    // there is no point going ahead :)\n    extend(OverlayViewSafe, google.maps.OverlayView);\n  }\n}\n"],"names":["check","it","Math","globalThis","window","self","global","this","Function","exec","error","fails","Object","defineProperty","get","$propertyIsEnumerable","propertyIsEnumerable","getOwnPropertyDescriptor","call","V","descriptor","enumerable","bitmap","value","configurable","writable","toString","slice","split","classof","undefined","TypeError","IndexedObject","requireObjectCoercible","input","PREFERRED_STRING","isObject","fn","val","valueOf","argument","hasOwnProperty","hasOwn","key","toObject","document","EXISTS","createElement","DESCRIPTORS","a","$getOwnPropertyDescriptor","O","P","toIndexedObject","toPrimitive","IE8_DOM_DEFINE","has","createPropertyDescriptor","propertyIsEnumerableModule","f","String","$defineProperty","Attributes","anObject","object","definePropertyModule","createNonEnumerableProperty","SHARED","setGlobal","functionToString","store","inspectSource","set","WeakMap","test","module","push","version","mode","copyright","id","postfix","random","keys","shared","uid","OBJECT_ALREADY_INITIALIZED","NATIVE_WEAK_MAP","state","wmget","wmhas","wmset","metadata","facade","STATE","sharedKey","hiddenKeys","objectHas","match","enforce","getterFor","TYPE","type","getInternalState","InternalStateModule","enforceInternalState","TEMPLATE","options","unsafe","simple","noTargetGet","source","join","prototype","aFunction","variable","namespace","method","arguments","length","path","ceil","floor","isNaN","min","toInteger","max","index","integer","createMethod","IS_INCLUDES","$this","el","fromIndex","toLength","toAbsoluteIndex","includes","indexOf","require$$0","names","i","result","enumBugKeys","concat","getOwnPropertyNames","internalObjectKeys","getOwnPropertySymbols","getBuiltIn","getOwnPropertyNamesModule","getOwnPropertySymbolsModule","target","ownKeys","getOwnPropertyDescriptorModule","replacement","isForced","feature","detection","data","normalize","POLYFILL","NATIVE","string","replace","toLowerCase","targetProperty","sourceProperty","TARGET","GLOBAL","STATIC","stat","forced","copyConstructorProperties","sham","redefine","Array","isArray","arg","process","versions","v8","userAgent","symbol","Symbol","V8_VERSION","NATIVE_SYMBOL","iterator","WellKnownSymbolsStore","createWellKnownSymbol","USE_SYMBOL_AS_UID","withoutSetter","name","SPECIES","wellKnownSymbol","originalArray","C","constructor","IS_MAP","IS_FILTER","IS_SOME","IS_EVERY","IS_FIND_INDEX","IS_FILTER_OUT","NO_HOLES","callbackfn","that","specificCreate","boundFunction","b","c","apply","bind","create","arraySpeciesCreate","forEach","map","filter","some","every","find","findIndex","filterOut","METHOD_NAME","array","foo","Boolean","$map","proto","arrayMethodHasSpeciesSupport","IS_RIGHT","argumentsLength","memo","left","right","$reduce","arrayMethodIsStrict","IS_NODE","CHROME_VERSION","reduce","$filter","Cluster","markers","position","google","maps","LatLng","_position","bounds","marker","extend","getPosition","LatLngBounds","getCenter","m","getVisible","setMap","filterMarkersToPaddedViewport","mapCanvasProjection","viewportPadding","extendedMapBounds","extendBoundsToPaddedViewport","getBounds","contains","projection","pixels","latLngBoundsToPixelBounds","northEast","southWest","extendedPixelBounds","extendPixelBounds","pixelBoundsToLatLngBounds","distanceBetweenPoints","p1","p2","dLat","lat","PI","dLon","lng","sin","cos","atan2","sqrt","fromLatLngToDivPixel","getNorthEast","getSouthWest","x","y","fromDivPixelToLatLng","AbstractAlgorithm","maxZoom","noop","AbstractViewportAlgorithm","_a","getZoom","cluster","$forEach","COLLECTION_NAME","CSSRuleList","CSSStyleDeclaration","CSSValueList","ClientRectList","DOMRectList","DOMStringList","DOMTokenList","DataTransferItemList","FileList","HTMLAllCollection","HTMLCollection","HTMLFormElement","HTMLSelectElement","MediaList","MimeTypeArray","NamedNodeMap","NodeList","PaintRequestList","Plugin","PluginArray","SVGLengthList","SVGNumberList","SVGPathSegList","SVGPointList","SVGStringList","SVGTransformList","SourceBufferList","StyleSheetList","TextTrackCueList","TextTrackList","TouchList","Collection","CollectionPrototype","toJSON","URL","GridAlgorithm","maxDistance","gridSize","clusters","_this2","addToClosestCluster","candidate","distance","NoopAlgorithm","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","point","coordinates","properties","Error","isNumber","geom","feat","bbox","geometry","featureCollection","features","fc","radiansToLength","units","factor","degreesToRadians","convertLength","originalUnit","finalUnit","lengthToRadians","num","clone","geojson","cloneFeature","cloned","cloneFeatureCollection","cloneGeometry","cloneProperties","item","geometries","g","deepSlice","coords","coord","coordEach","callback","excludeWrapCoord","j","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geomIndex","multiFeatureIndex","geometryIndex","geomType","coordAll","len","ks","d","prs","v","vlen","kmpp","init","count","Infinity","dist","old","vsum","sum","h","ksj","_j3","cj","_i2","KmeansAlgorithm","numberOfClusters","points","round","mutate","initialCentroids","skmeansResult","skmeans","centroids","idx","featureEach","clusterId","idxs","centroid","clustersKmeans","$assign","assign","A","B","alphabet","chr","objectKeys","T","S","getCoord","from","to","coordinates1","coordinates2","lat1","lat2","pow","DBSCAN","dataset","epsilon","minPts","distanceFunction","_euclideanDistance","noise","_visited","_assigned","_datasetLength","_init","run","pointId","neighbors","_regionQuery","_addToCluster","_expandCluster","pointId2","neighbors2","_mergeArrays","p","q","exports","KMEANS","assignments","randomCentroid","change","centroidId","mean","maxDim","dim","getClusters","maxId","closestCentroid","argmin","Number","MAX_VALUE","diff","PriorityQueue","elements","priorities","sorting","_queue","_priorities","_sorting","insert","ele","priority","indexToInsert","priority2","_insertAt","remove","splice","func","getElements","getElementPriority","getPriorities","getElementsWithPriorities","OPTICS","_reachability","_processed","_coreDistance","_orderedList","priorityQueue","_distanceToCore","_updateQueue","getReachabilityPlot","reachabilityPlot","queue","newReachableDistance","queueElements","coreDistCand","require$$1","require$$2","require$$3","DEFAULT_INTERNAL_DBSCAN_OPTION","minPoints","DBScanAlgorithm","projectedPoint","fromLatLngToContainerPixel","grouped","dbscan","clustering","clusteredIds","clusterIds","clusterPoint","noiseId","noisePoint","clustersDbscan","sortKD","ids","nodeSize","depth","select","inc","n","z","log","s","exp","sd","t","swapItem","swap","arr","tmp","sqDist","ax","ay","bx","by","dx","dy","defaultGetX","defaultGetY","KDBush","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","sort","range","minX","minY","maxX","maxY","stack","axis","pop","nextAxis","within","r","qx","qy","r2","defaultOptions","minZoom","radius","extent","generateId","props","fround","Float32Array","Supercluster","trees","load","console","time","timerId","createPointCluster","timeEnd","now","Date","_cluster","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","tree","_limitZoom","lngX","latY","numPoints","getClusterJSON","getChildren","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","origin","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","_addTileFeatures","getClusterExpansionZoom","expansionZoom","cluster_id","skipped","child","point_count","isCluster","tags","px","py","getClusterProperties","neighborIds","numPointsOrigin","neighborId","wx","wy","clusterProperties","_map","numPoints2","createCluster","original","yLat","abbrev","point_count_abbreviated","y2","atan","dest","src","equal","Map","size","entries","Set","ArrayBuffer","isView","RegExp","flags","SuperClusterAlgorithm","superCluster","SuperCluster","_this","west","south","east","north","transformCluster","leaf","$indexOf","nativeIndexOf","NEGATIVE_ZERO","STRICT_METHOD","searchElement","propertyKey","HAS_SPECIES_SUPPORT","MAX_SAFE_INTEGER","MAXIMUM_ALLOWED_LENGTH_EXCEEDED","start","deleteCount","insertCount","actualDeleteCount","actualStart","createProperty","activeXDocument","setPrototypeOf","setter","CORRECT_SETTER","aPossiblePrototype","__proto__","dummy","Wrapper","NewTarget","NewTargetPrototype","defineProperties","Properties","IE_PROTO","EmptyConstructor","scriptTag","content","LT","NullProtoObject","domain","ActiveXObject","iframeDocument","iframe","write","close","temp","parentWindow","NullProtoObjectViaActiveX","documentCreateElement","style","display","html","appendChild","contentWindow","open","F","whitespace","ltrim","rtrim","end","trim","NUMBER","NativeNumber","NumberPrototype","BROKEN_CLASSOF","toNumber","first","third","radix","maxCode","digits","code","charCodeAt","NaN","parseInt","NumberWrapper","inheritIfRequired","ClusterStats","clusterMarkerCounts","clusterMarkerSum","DefaultRenderer","stats","color","svg","btoa","Marker","icon","url","scaledSize","Size","label","text","fontSize","zIndex","MAX_ZINDEX","MarkerClustererEvents","OverlayViewSafe","type1","type2","property","OverlayView","defaultOnClusterClickHandler","_","fitBounds","MarkerClusterer","algorithm","renderer","onClusterClick","noDraw","render","addMarker","removed","_this3","removeMarker","_this4","getMap","getProjection","event","trigger","CLUSTERING_BEGIN","calculate","reset","renderClusters","CLUSTERING_END","idleListener","addListener","removeListener","delete","_this5","CLUSTER_CLICK"],"mappings":"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"}